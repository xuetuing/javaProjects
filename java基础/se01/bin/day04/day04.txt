泛型		java1.5之后推出的新特性
public class Point<X,Y>{}
Point<Integer,Integer> p = new Point<Integer,Integer>(1,2);

Iterator iterator():返回用于遍历集合的迭代器

ArrayList 和 Vector的比较
ArrayList在JDK1.2版本以后采用了变长数组算法实现，线程不安全，
效率高速度快
Vector 在JDK1.0版本出现，底层也是采用了变长数组算法实现，线程安全
效率低，实现了List接口

ArrayList 和 LinkedList的比较
LinkedList 是采用双向链表的结构实现的，更适合频繁的增删操作
ArrayList 是采用变长数组算法实现的，更适合查询数据

新循环:for each		JDK1.5之后推出的新特性
语法：
	for(元素类型 e : 集合或者数组){
		循环体
	}
新循环有别于传统循环，其出现的目的是为了简化遍历集合或者数组




队列：Queue
队列也是用来保存一组数据，但是有别于数组和集合，队列存取元素必须遵循
先进先出的原则（FIFO）

队列的遍历是一次性的，想要获取队列中的某个元素，就必须先将队列中该元素
之前的所有元素取出后才能使用和访问

LinkedList具有存取效率高的特点，Java使用该类作为队列的实现类使用

队列的相关方法：
boolean offer(E e):队尾追加元素
E poll():获取并从队列中删除队首元素
E peek():仅获取队首元素

双端队列：Deque
队列两端都可以出队入队

使用双端队列存取元素时，只从一侧操作时，就形成了一种存取模式：
先进后出，就形成了经典的数据结构：栈，使用栈是为了操作具有可追溯性，
通常实现某个操作有后退功能时，常使用栈

集合的排序：Collections是集合的工具类，其中有一个静态方法sort()
用于排序集合元素，这里的排序仅针对于List集合

Comparable接口：该接口的实现类是可比较的    (默认)
实现该接口必须实现方法：public interface Comparable{
					public int compareTo(T t);  //比较规则的重写
				}
compareTo()的返回值：不关心具体值，只关心取值范围
当返回值大于0:当前对象比给定对象大
返回值小于0：当前对象比给定对象小
等于0：两者相等

Comparator接口：比较工具，用于临时定义比较规则
class MyComparator implements Comparator<String>{}

内部类：根据位置的不同分为
1.静态内部类

2.成员内部类

3.局部内部类

4.匿名内部类：当定义一个类需要实现某个接口，或者某个类时
并且定义的类只在某段代码中使用一个实例，其他地方都不会用到
时，首选使用匿名内部类




















































