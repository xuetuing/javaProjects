内部类：根据位置的不同分为
1.静态内部类
	a.使用static修饰，声明在类体中
	b.静态内部类可以访问外部类的静态成员
2.成员内部类
	a.声明在类体中，不使用static修饰，具有类的成员特征，必须有
	外部类实例才能创建内部类实例
	b.内部类实例可以访问共享外部类的成员变量
3.局部内部类
	a.把类声明在方法中(很少见)
	b.可以共享访问外部方法的局部变量，局部变量必须是final修饰的
	c.作用域类似于局部变量
	
4.匿名内部类：当定义一个类需要实现某个接口，或者某个类时
并且定义的类只在某段代码中使用一个实例，其他地方都不会用到
时，首选使用匿名内部类
	a.匿名内部类非常常见，可以写在任何地方，就是一般的语句
	b.语法更像是创建对象		new Comparator<String>{};  //有分号
	c.匿名类是对原类的一个继承，同时还创建了实例，{}就是继承以后的类体，
	类体中可以使用所有类的语法
	d.匿名类不能写构造器
	e.匿名类可以从抽象类或者接口中继承、实现，必须提供抽象方法的实例
	
任何内部类都编译成独立的.class文件
内部类的最大作用："封装"
	
Set集合：无序，不重复
Set集合中不会出现两个equals比较为true的元素
TreeSet:使用二叉树实现(不常用)
HashSet:使用散列算法实现
	
HashSet:存取元素时依赖元素的hashCode()方法
hashCode()方法是Object定义的方法，所有的类都具备该方法
通常我们重写一个类的equals()时，要求连同重写hashCode()

重写hashCode()的注意事项：
1.hashCode()在被多次调用时应返回一个稳定的值，除非参与的equals()
比较的属性值发生变化
2.当两个对象equals()方法比较为true时，两个对象的hashCode()方法
返回值应当相同
3.当两个对象equals()方法比较为false时，不要求hashCode()方法返回
的结果不同，但不相等的两个对象使用不同的hashCode()会提高散列表的性能	
	
Map:是一个多行两列的表格，每一行存储一项     (不是集合)    Map<String,Integer> map = new HashMap<String,Integer>();
一项包含两个部分：key-value(键值对)	
常见的实现类：HashMap	使用散列算法实现的Map     Hashtable也可实现Map接口
1)容量：散列表中散列数组的大小  
2)散列运算：key-->散列值的算法（散列算法）
3)散列桶：散列值相同的元素的"线性集合"
4)加载因子：是散列数组的加载率，一般小于75%性能就比较理想
（元素数量/散列数组的大小）< 75%
5)散列查找：根据key计算散列值，根据散列值的下标找value
	
HashMap性能调优：
加载因子的比值超过0.75，散列数组将扩容，存在原来数组中的数据
要重新进行散列运算之后存入新数组，并不是简单的将原来数组中的数
据复制到新数组中，这个过程称为rehash(重新散列)，那么扩容数组，
rehash会带来一定的性能开销。
	
HashMap：以键值对存储对象，关键字key是唯一的，不重复的
1）key可以是任意对象，value可以是任意对象
2）key-value成对放置在集合中
3）重复的key算一个，重复添加时是替换操作
4）根据key的散列值计算散列表，元素按照散列值排序
5）HashMap的默认容量是16，默认的加载因子是0.75
6）HashMap可以根据key检索查找value的值
7）HashMap可以在构造中指定参数：初始容量和加载因子
	
Map常用方法：
V put(K k,V v):将一组key-value对存入Map,因为Map要求key
不允许重复，所以若使用相同的key出入不同的元素，是替换操作	,返回被替换的值

V get(Object k):根据k获得value，若无key,返回null

HashSet就是使用HashMap实现的，它利用了HashMap对于key不允许
重复的特点以及散列算法的优点
	
遍历Map的三种方式：
1.遍历所有的key
2.遍历所有的键值对
3.遍历所有的value(很少见)	
	
重点掌握：ArrayList	LinkedList	HashSet		HashMap
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	