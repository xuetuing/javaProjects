目录：
1.多线程实现方式
2.线程状态
3.线程优先级: 先将线程设置优先级再启动
4.线程安全，线程同步synchronized，Collections提供了将非线程安全的集合
转换为线程安全的方法
5.线程的协同工作,thread.join(),wait()+notify()+synchronized块
6.线程池Executors工厂，Executor,threadPool
7.计时器

A.创建线程的方式
1.继承Thread类
实现步骤：
1）继承Thread类，覆盖run()方法，提供并发运行的过程
2）创建这个类的实例，使用start()启动线程

2.实现Runnable接口
实现步骤：
1）实现Runnable接口，实现run()方法
2）创建这个类的实例，用这个实例作为Thread的构造参数，创建Thread对象
3）使用start()启动线程

3.使用内部类，匿名内部类创建线程
      
B.线程的状态
1.new			新建状态，还没有启动
2.runnable		可运行状态（线程准备就绪，属于等待状态）     
3.running		正在运行，该线程已获取了CPU资源
	a.假设线程获取了CPU,则进入running状态，开始执行线程体
	b.假设系统只有一个CPU，那么在任意时间点只有一条线程处于running状态
	如果是双核，那么同一时间点会有两条线程处于running状态，但是当线程数
	大于处理器数，依然会是多条线程在同一个CPU轮换执行      
	c.当一条线程开始运行时，如果它不是一瞬间完成，那么它不可能一直处于
	running状态，线程在执行过程中会被中断，目的是为了让其他线程获得执行
	机会，像这样的线程调度，取决于底层平台，对于抢占式策略的平台，系统会给
	每一个可执行线程一小段时间来处理任务。当该时间片段用完了，系统会剥夺线
	程所占资源CPU,让其他线程获得运行的机会。
4.block		阻塞状态（挂起）      
	a.一下情况会发生阻塞状态
	1>线程使用了sleep()，主动放弃CPU资源    running-->block-->runnable-->running
	2>线程调用了阻塞式IO方法（比如控制台输入方法），在该方法返回前，该线程被阻塞
	.....
    b.当正在执行的线程被阻塞的时候，其他线程就获得机会，阻塞结束时，该线程就进入
    runnable等待状态而非直接进入running状态
5.dead		死亡状态
	run()方法执行结束，线程进入死亡状态，不要试图对一个已经死亡的线程调用
	start()，死亡后将再次作为线程执行，会抛出异常
  

线程的两种协同工作方式：
1.thread.join()    等待该线程结束
2.wait()+notify()  两个方法属于Object,需要加同步锁 
 
线程安全问题：
多线程并发访问同一个资源，会产出线程安全问题
解决办法：把异步操作变成同步操作
1）多线程并发读写同一个临界资源会发生“线程安全并发问题”,如果保证多线程
同步访问临界资源，就可以解决线程安全问题
2）常见的临界资源：
	多线程共享的实例变量
	静态的公共变量
3）异步：执行没有先后顺序		各做各的		Ajax
      同步：执行有先后顺序		你做完我做
4）同步锁：synchronized关键字
synchronized可以修饰方法，当一个方法被修饰后，这个方法就是同步方法
同一时刻只能有一个线程访问该方法

synchronized块
当一个方法被修饰后，该方法为同步方法，虽然保证了代码的执行安全，但是
效率低下，我们实际上只需要将方法中需要同步的代码片段加锁，这样可以缩小
同步范围，从而提高代码的运行效率
语法：
synchronized(同步监视器){
	需要同步的代码片段
}
同步监视器：就是一个对象，任何对象都可以，但要保证一点，多线程看到的
是“同一个对象”，一般情况下可以用this
 
同步的实现方法有5种：1.同步方法；2.同步代码块；3.使用特殊域变量（volatile）
4.使用重入锁；5.使用局部变量      
      
线程池：JDK1.5提供了并发包concurrent
Executors是工厂，包含工厂用于创建Executor接口的实例     
Executor threadPool = Executors.newFixedThreadPool(2); //创建了两个线程     
threadPool.execute(task); //将任务（Runnable的实现类）添加到线程池    
     
程序、进程、线程三者之间的关系：
程序是由一个或多个进程组成的，进程又是由一个或多个线程组成的

线程的状态管理:
1）Thread.sleep(times):线程从running-->block,休眠times毫秒
再返回runnable等待状态，如果其他线程调用interrupt()打断了线程block
状态，就会发生InterruptedException中断异常

2）Thread.yield():主动让出CPU资源，线程让出处理器，离开running状态，使它
进入runnable状态

线程的常用属性和方法：
1.线程的优先级			getPriority		1-10
2.后台线程			setDaemon(true)
3.获取线程名字			getName()
4.获取当前线程			Thread.currentThread();
      
java计时器（定时器）	Timer类
1）可以安排自动计划任务的类，每一个任务都是一个线程
2）创建Timer实例，timer.schedual()可以为Timer实例增加计划任务
计划任务是一个接口（TimerTask）      
3）cancel()清除计时器上的所有计划任务

  等待池和等锁池

sleep()和yield()的区别
			sleep()					yield()
优先级		不考虑					考虑，同级及以上
进入状态		阻塞状态					就绪状态
抛出异常		InterruptedException	无异常
移植性		sleep()比yield()好（和操作系统CPU调度有关）

sleep()和wai()的区别
				sleep() 				wait()
归属				Thread的静态方法			Object类的方法
是否放弃对象锁		不放弃					放弃
让出CPU			让出						让出
进入状态			阻塞						对象等待池
恢复				休眠时间结束后进入就			对象调用notify()或者notifyAll()方法后
				绪状态（等cpu时间）			进入等锁池，获得对象锁后进入就绪状态

对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以防止多个任务同时
访问该对象内存。


















