/*本文件涉及java的一些底层实现学习*/
1.Map底层架构：HashMap
HashMap的底层结构实际上是"链表散列"，即数组和链表的结合体。
1.6版本
HashMap在底层将key-value作为一个整体处理，就是Entry对象。底层采用一个Entry[]
数组来保存所有key-value对，当需要存储一个Entry对象时，会根据hash算法来决定其在数组
中的存储位置（下标是根据hash值和数组length-1按位与运算得到？），再根据equals()方法决定其在
该数组位置上的链表中的存储位置。当需要取出一个Entry时，也会根据hash算法找到器在数组中的位置，
再根据equals()方法从该位置上的链表中
取出该Entry.
1.8版本有所改变！！

构造函数： public HashMap(){容量及容量因子}
存储数据结构：
Entry:  //用来得到Entry[] table
	static class Entry<K,V> implements Map.Entry<K,V> {
        final K key;
        V value;
        Entry<K,V> next;
        final int hash;
     }
计算hash值：
static int hash(int h) {
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }
存数据：
public V put(K key, V value) {
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key.hashCode());  //计算hash值，其中hashcode()是object的方法
        int i = indexFor(hash, table.length); //根据hash值计算在数组中的下标 按位与运算
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {  //检查否已经存在
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i); //进行添加
        return null;
    }
取数据：
 public V get(Object key) {
        if (key == null)
            return getForNullKey();
        int hash = hash(key.hashCode());  //计算hash
        for (Entry<K,V> e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k)))  //匹配对象
                return e.value;
        }
        return null;
    }
1.8版本中，加入了红黑树的实现，当链表长度大于8时，转换为红黑树的结构。



2.LinkedHashMap:


3.TreeMap:


ConcurrentHashMap:

ConcurrentSkipListMap:


HashMap和Hashtable的区别



transient:用来表示不是该对象串行化的一部分。不希望该部分用Serialization机制来保存它。
串行化：Serialization,将对象存储到介质中或以二进制方式通过网络传输，是一种持久化方法。

hashCode()和equals()方法的区别：
两个方法的作用一样，用来对比两个对象是否相等。equals()比较的比较全面复杂，效率较低，而利用
hashCode()对比，效率很高，但并不是完全可靠，有时候不同对象可能生成相同值，hashCode()在
大部分时候可靠，不是绝对可靠。
	equals()相等的两个对象，其hashCode()肯定相等，而hashCode()相等的两个对象，它们的
equals()不一定相等。在需要进行大量并且快速的对比，使用equals()效率太低，先判断hashCode()
，如果不等则没必要比较hashCode(),效率提高很多。











































