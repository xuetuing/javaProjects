对象的实例化过程：实例化子类，会递归的分配所有的父类空间，然后再分配子类空间
1.创建类对象之前，检查类是否加载（将硬盘上的.class文件加载到内存中）
如果没有就必须加载这个类，在这个类加载之前要加载所有的父类
2.java运行时采用的策略是：懒惰式加载（按需加载），如果第一次用到就加载，
而且只加载一次。通过classPath指定的路径来寻找类文件，加载以后是一个对象，
类型是Class。
3.在内存堆中分配对象的空间，递归分配所有父类和子类的空间
4.调用父类的构造器，再调用本类构造器

方法的重写：子类型中修改父类型的方法，子类重写父类方法的功能
方法重写只改变方法体，不改变方法名和参数列表

案例：飞行物的碰撞测试
1）飞行物都可以检测是否被击中
2）具体的飞行物类型（敌机，小蜜蜂），来重写具体的被击中的检测方法
3）调用击中检测方法，由具体的飞行物类型决定，调用具体的类型的方法

重写方法的调用规则：在运行期间调用对象的方法

2.多态：对象的多态和方法的多态
对象的多态：父类的引用指向子类的对象，父类的实现是多态的
方法的多态：方法的重载

3.封装：将敏感信息私有化（访问控制（访问控制修饰符）：体现了封装现象）
访问控制修饰符（修饰java类、属性、方法的访问可见范围）

				类内			包内			子类			任意
public			√			√			√			√
protected		√			√			√
default			√			√
private			√

public  公共的，公有的，任何位置可见（类内部，同一包中，包外和其他地方）
protected    保护的，在同一个包中和包外有继承关系的子类可见
default     默认的，本类和同一包中可见
private     私有的，仅在同一类内部可见

访问控制原则：尽可能的封装

java继承语法：
1.父类类型可以引用子类型实例，父类型的实现的多态的
2.子类可以覆盖父类的方法，修改父类的行为（功能）
3.方法的覆盖：子类覆盖了父类的“相同方法签名”的方法
4.方法的覆盖由方法的动态绑定决定：java虚拟机在运行的时候给确定执行
哪个对象的哪个方法，最终方法绑定到对象。
总结：属性静态的绑定到变量类型，方法动态绑定到对象

控制台打印题目(单选题和多选题)，用户输入答案，判断答案是否正确
父类：题目Question(题号id(int),题目text(String),选项options（String[]）)
方法： 1.打印一个题目到控制台print()
     2.检查答案是否正确的方法     check()
     
     子类：单选题SingleQuestion    标准答案 answer(char)
               多选题MultiQuestion     标准答案 answer(char[])

引用类型的转换：
1.向上转型（自动类型转换）      小到大
2.向下转型（强制类型转换）      大到小
3.instanceof 运算符   用来检查引用类型的类型，经常与引用类型的向下转型配合使用实现安
全的类型转换，避免类型转换异常














