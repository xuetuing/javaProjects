java安装目录中的bin和lib：
1)bin中包含着java的可执行文件，配置%JAVA_HOME%到PATH就是指明执行文件的路径
配置方式：
JAVA_HOME:父路径
PATH:%JAVA_HOME%/bin;%JAVA_HOME%/jre/bin;
2)CLASSPATH的作用是指明java类所在的目录
通常配置：.;%JAVA_HOME%/lib/tools.jar;%JAVA_HOME%/lib/dt.jar;


1.抽象类和接口的区别：
					抽象类							接口					
组成				常量，变量，普通方法，抽象方法			全局常量，抽象方法
				构造方法，	static方法
关键字			abstract						interface
实例化			不可实例化，只能引用子类对象			不可实例化，只能引用子类对象
权限				各种权限							只能public
子类的使用			必须有子类，子类extends抽象类			必须有子类，子类implements多
				实现抽象类父类中所有方法(抽象类除外)		个接口，实现接口中所有方法
限制				单继承限制							没有单继承限制，一个子类可实现多个接口
继承关系			抽象类可实现多个接口，继承单个类		接口被类实现，也可继承多个接口					

工厂设计模式：Factory   结构及代码示例
代理设计模式：proxy		结构及代码示例

2.@override 和@overload的区别
					 override					overload
含义					       重写						重载
使用				      子类重写父类方法					同一类中
特征变化			   函数名和参数都不变				函数类型不变，参数数量或类型改变

3.this和super,this()和super()的区别：
	this代表类对象本身，可以理解为：指向对象本身的一个指针。当想要引用当前对象的某个属性或方法
是可以用this，但this只能在类中的非静态方法中使用，静态方法和静态代码块中不能出现this.
	super可以理解为指向自己父类的一个指针，而且是离自己最近的一个父类。通过super可以获取
被局部变量屏蔽掉的父类对象的某个同名变量的值。
	
	this()：调用本类中无参构造器(应该为构造函数中的第一条语句)
	super():调用父类中的无参构造器（应该为构造函数中的第一条语句）

 方法中的this变量：
 1.this是引用变量，引用调用方法这个对象的自身
 2.this是局部变量，是方法的隐含参数，调用方法的时候是当前对象的引用，隐含传递给this变量
 3.在方法结束后this被回收
 
 注意:this是在方法运行期有效，并且引用调用方法当前对象，当在方法中
 不能区分局部变量和实例变量的时候，就不能省略this


4.java中栈和堆得特点？
1.计算机执行java程序会在栈内存中开辟一块栈区间（存放变量），在运行期间，jvm会开辟一个
堆内存空间
2.栈区间存储特点"先进后出"，堆空间的存储方式比较散漫，随机分配的一片空间，随处“堆放”
3.引用变量在栈中声明，new运算生成的对象在堆中分配空间（根据属性来分配空间），并且会自动给属性初始化

注意：
1）栈内存的引用变量会指向堆内存中的实例对象
2）属性有初始值（默认为"零"值）
3）将堆中的东西称为对象，对应现实世界中的事

5.static关键字的特点？
静态的，其修饰的资源都是类级别的，是全体对象实例共享的资源
1）属性
	-->使用static修饰的属性，属于全体实例对象共享的资源
	-->静态属性在类加载期间会被初始化
	-->类名.属性名 访问
2）方法
	访问静态方法可以直接用  类名.方法名  访问
	同一类中静态方法中可以访问静态属性，方法（实质是类.方法名的访问方法），
	非静态方法不可以（加载顺序的限制）
	普通方法只能用对象调用

静态的，使用static修饰的，在类加载之前先加载                      加载顺序

共享	先期加载及初始化	类访问	静态方法的访问

6.final关键字的特点？
1）final修饰的类，不能被继承
   -->java的String就是final类，不能被继承
   -->Math也是final类，不能被继承
   -->Integer、Long、Double等包装类都是不能被继承的
   -->在实际项目中，原则上不能使用final修饰的类     "动态继承代理"
2）final修饰的方法不能被覆盖（重写）
3）final修饰的变量，初始化后不允许再修改
4）final static修饰的变量作为常量（要求常量名都是大写字母）

从类，变量，方法方面：类不能被继承，方法不能被覆盖，变量不能被修改，常量的定义final static

7.java是怎么运行的？
java是编译型和解释型语言的结合体。
1）编写java源程序，文件是.java格式的
2）首先采用通用的java编译器将源程序编译成为与平台无关的字节码文件
3）再由java虚拟机（JVM）字节码文件解释执行
注意：java字节码具有平台无关性，但是不同的系统平台需要不同版本的虚拟机。

8.数组的三种初始化方式？
1）int[] a = new int[3];
2）int[] a = new int[]{1,2,3};
3）int[] a = {1,2,3};


16.大整型，大浮点型数据：
java.math.BigInteger
大整型，可以保存的数字比Long大的整型

java.math.BigDecimal
可以做很精确的小数运算，并且可以保存很精确的小数
四种运算方法：add(),subtract(),multiply(),divide()

17.内部类：根据位置的不同分为
1.静态内部类
	a.使用static修饰，声明在类体中
	b.静态内部类可以访问外部类的静态成员
2.成员内部类
	a.声明在类体中，不使用static修饰，具有类的成员特征，必须有
	外部类实例才能创建内部类实例
	b.内部类实例可以访问共享外部类的成员变量
3.局部内部类
	a.把类声明在方法中(很少见)
	b.可以共享访问外部方法的局部变量，局部变量必须是final修饰的
	c.作用域类似于局部变量
	
4.匿名内部类：当定义一个类需要实现某个接口，或者某个类时
并且定义的类只在某段代码中使用一个实例，其他地方都不会用到
时，首选使用匿名内部类
	a.匿名内部类非常常见，可以写在任何地方，就是一般的语句
	b.语法更像是创建对象		new Comparator<String>{};  //有分号
	c.匿名类是对原类的一个继承，同时还创建了实例，{}就是继承以后的类体，
	类体中可以使用所有类的语法
	d.匿名类不能写构造器
	e.匿名类可以从抽象类或者接口中继承、实现，必须提供抽象方法的实例
	
任何内部类都编译成独立的.class文件
内部类的最大作用："封装"

java中lang包默认导入，不用手动导入

位移运算符：
>>：右移运算符，将左操作数向右移动，移位个数由右操作数决定  
<<：左移运算符，将左操作数向左移动，移位个数由右操作数决定
>>>：无符号左移位运算符
例子： 2<<2 = 2*(2*2)=8  右移类似(除法)

负数的位移运算？
变量定义时未初始化值，但在被用到时会有默认值。

instant variable 实例变量，即成员变量
class Something{
	int i;   //正确，有默认值0
	final int i; //错误，final修饰的没有默认值，必须在构造器结束前赋值
	
	public void doSomething(){
		System.out.println("i="+1);
	}
}

java中以Unicode编码,一个字符2个字节,一个汉字,数字,或英文都是一个字符。
















































