<!DOCTYPE html>
<!-- saved from url=(0061)https://www.cnblogs.com/chenyankai/recentcomments.html?page=3 -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<title>最新评论 - hunyihun - 博客园</title>
<link type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园3_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园3_files/bundle-classic.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园3_files/bundle-classic-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/chenyankai/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/chenyankai/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/chenyankai/wlwmanifest.xml">
<script async="" src="./最新评论 - hunyihun - 博客园3_files/analytics.js.下载"></script><script src="./最新评论 - hunyihun - 博客园3_files/jquery-2.2.0.min.js.下载"></script>
<script type="text/javascript">var currentBlogApp = 'chenyankai', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./最新评论 - hunyihun - 博客园3_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<table align="center" width="98%" cellspacing="0" cellpadding="0" border="0" style="margin-top:10px">
<tbody><tr>
	<td valign="top" width="70%" style="padding:0">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
<div id="header">
	<span>
		<a id="Header1_HeaderTitle" href="https://www.cnblogs.com/chenyankai/">hunyihun</a><br>
		<div class="sub"></div>
	</span>
</div>
			</td>
		</tr>
		</tbody></table>
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white" class="index">
		<tbody><tr>
			<td class="main">
			

<div id="myposts">
<h3 class="myposts_title">最新评论</h3>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;3&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">下一页</a>&nbsp;
</div></div>

		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_0" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097225">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:01</span>&nbsp;&nbsp;</div>
			<div class="postText2">B.	建议（3级或以上）<br>1.	为 switch 语句提供一个 default 选项。<br>2.	不要在 for 循环体中对计数器的赋值。<br>3.	不要给非公有类定义 public 构建器。<br>4.	不要对浮点数进行比较运算，尤其是不要进行 ==, !=运算，减少 &gt;, &lt; 运算。<br>5.	实现 equals() 方法时，先用 getClass() 或者 instanceof 进行类型比较，通过后才能继续比较。<br>6.	不要重载 main() 方法用作除入口以外的其他用途。<br>7.	方法的参数名不要和类中的方法名相同。<br>8.	除了构建器外，不要使用和类名相同的方法名。<br>9.	不要定义 Error 和 RuntimeException 的子类，可以定义 Exception 的子类。<br>10.	线程中需要实现 run() 方法。<br>11.	使用 equals() 比较两个类的值是否相同。<br>12.	字符串和数字运算结果相连接的时候，应该把数字运算部分用小括号括起来。<br>13.	类中不要使用非私有（公有、保护和友好）的非静态属性。<br>14.	在类中对于没有实现的接口，应该定义成抽象方法，类应该定义成抽象类。（5级）<br>15.	不要显式导入 java.lang.* 包；<br>16.	初始化时不要使用类的非静态属性。<br>17.	显式初始化所有的局部变量。<br>18.	按照方法名把方法排序放置，同名合同类型的方法应该放在一起。<br>19.	不要使用嵌套赋值，即在一个表达式中使用多个 = 。<br>20.	不要在抽象类的构建器中调用抽象方法。<br>21.	重载 equals() 方法的同时，也应该重载 hashCode() 方法。<br>22.	工具类（Utility）不要定义构建器，包括私有构建器。<br>23.	不要在 switch 中使用10个以上的 case 语句。<br>24.	把 main() 方法放在类的最后。<br>25.	声明方法违例的时候不要使用 Exception ，应该使用它的子类。<br>26.	不要直接扔出一个Error ，应该扔出它的子类。<br>27.	在进行比较的时候，总是把常量放在同一边（都放在左边或者都放在右边）。<br>28.	在可能的情况下，总是为类定义一个缺省的构建器。<br>29.	在捕获违例的时候，不使用 Exception, RuntimeException, Throwable，尽可能使用它们的子类。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_1" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097222">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:01</span>&nbsp;&nbsp;</div>
			<div class="postText2">V.	JTEST规范<br>A.	规则（1-2级）<br>1.	在switch 中每个 case 语句都应该包含 break 或者 return 。<br>2.	不要使用空的for 、if  、while 语句。<br>3.	在运算中不要减小数据的精度。<br>4.	switch 语句中的 case 关键字要和后面的常量保持一个空格，switch 语句中不要定义case 之外的无用标签。<br>5.	不要在if 语句中使用等号= 进行赋值操作。<br>6.	静态成员或者方法使用类名访问，不使用句柄访问。<br>7.	方法重载的时候，一定要注意方法名相同，避免类中使用两个非常相似的方法名。<br>8.	不要在ComponentListener.componentResized() 方法中调用 serResize() 方法。<br>9.	不要覆盖父类的静态方法和私有方法。<br>10.	不要覆盖父类的属性。     <br>11.	不要使用两级以上的内部类。<br>12.	把内部类定义成私有类。<br>13.	去掉接口中多余的定义（不使用 public, abstract, static, final 等，这是接口中默认的）。<br>14.	不要定义不会被用到的局部变量、类私有属性、类私有方法和方法参数。<br>15.	显式初始化所有的静态属性。<br>16.	不要使用 System.getenv() 方法。<br>17.	不要硬编码 ‘\n’和‘\r’作为换行符号。<br>18.	不要直接使用 java.awt.peer.* 里面的接口。<br>19.	使用 System.arraycopy() ，不使用循环来复制数组。<br>20.	避免不必要的 instanceof 比较运算和类造型运算。<br>21.	不要在 finalize() 方法中删除监听器（Listeners）。<br>22.	在 finalize() 方法中一定要调用 super.finalize() 方法。<br>23.	在 finalize() 方法中的 finally 中调用 super.finalize() 方法。<br>24.	进行字符转换的时候应该尽可能的较少临时变量。<br>25.	使用ObjectStream 的方法后，调用reset() ，释放对象。<br>26.	线程同步中，在循环里面使用条件测试（使用 while(isWait) wait() 代替 if(isWait) wait()）。<br>27.	不掉用 Thread 类的 resume(), suspend(), stop() 方法。<br>28.	减小单个方法的复杂度，使用的 if, while, for, switch 语句要在10个以内。<br>29.	在Servlets中，重用JDBC连接的数据源。<br>30.	减少在Sevlets中使用的同步方法。<br>31.	不定义在包中没有被用到的友好属性、方法和类。<br>32.	没有子类的友好类应该定义成 final 。<br>33.	没有被覆盖的友好方法应该定义成 final 。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_2" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097221">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:00</span>&nbsp;&nbsp;</div>
			<div class="postText2">B.	建议<br>1.	记录异常不要保存exception.getMessage()，而要记录exception.toString()。<br>	示例：NullPointException抛出时常常描述为空，这样往往看不出是出了什么错。<br>	<br>2.	一个方法不应抛出太多类型的异常。<br>	说明： 如果程序中需要分类处理，则将异常根据分类组织成继承关系。如果确实有很多异常类型首先考虑用异常描述来区别，throws/exception子句标明的异常最好不要超过三个。<br>	<br>3.	异常捕获尽量不要直接 catch (Exception ex)，应该把异常细分处理。<br>	<br>4.	*如果多段代码重复做同一件事情，那么在方法的划分上可能存在问题。  <br>	说明：若此段代码各语句之间有实质性关联并且是完成同一件功能的，那么可考虑把此段代码构造成一个新的方法。<br>	<br>5.	对于创建的主要的类，最好置入main()函数，包含用于测试那个类的代码  。<br>	说明：主要类包括：<br>	1、能完成独立功能的类，如通讯。<br>	2、具有完整界面的类，如一个对话框、一个窗口、一个帧等。<br>	3、JavaBean 类。<br>	示例：<br>	public static void main(String[] arguments)<br>	{<br>	       CreateCircuitDialog circuitDialog1 = new CreateCircuitDialog (null, "Ciruit",  false);<br>	       circuitDialog1.setVisible(true);<br>	}<br>	<br>6.	集合中的数据如果不使用了应该及时释放，尤其是可重复使用的集合。<br>	说明：由于集合保存了对象的句柄，虚拟机的垃圾收集器就不会回收。<br>	<br>7.	*源程序中关系较为紧密的代码应尽可能相邻。<br>	说明：便于程序阅读和查找。<br>	示例：矩形的长与宽关系较密切，放在一起。 <br>	rect.length = 10;<br>	rect.width = 5;<br>	<br>8.	*不要使用难懂的技巧性很高的语句，除非很有必要时。<br>	说明：高技巧语句不等于高效率的程序，实际上程序的效率关键在于算法。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_3" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097220">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:00</span>&nbsp;&nbsp;</div>
			<div class="postText2">13.	*注释与所描述内容进行同样的缩排。<br>	说明：可使程序排版整齐，并方便注释的阅读与理解。<br>	示例：如下例子，排版不整齐，阅读稍感不方便。<br>	public void example( )<br>	{<br>	// 注释<br>	    CodeBlock One<br>	<br>	        // 注释<br>	    CodeBlock Two<br>	}<br>	应改为如下布局。<br>	public void example( )<br>	{<br>	    // 注释<br>	    CodeBlock One<br>	<br>	    // 注释<br>	    CodeBlock Two<br>	}<br>	<br>14.	*将注释与其上面的代码用空行隔开。<br>	示例：如下例子，显得代码过于紧凑。<br>	//注释<br>	program code one<br>	//注释<br>	program code two<br>	<br>	应如下书写：<br>	//注释<br>	program code one<br>	<br>	//注释<br>	program code two<br>	<br>15.	*对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。<br>	说明：这些语句往往是程序实现某一特定功能的关键，对于维护人员来说，良好的注释帮助更好的理解程序，有时甚至优于看设计文档。<br>	<br>16.	*对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。<br>	说明：这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。<br>	<br>17.	*边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>	<br>18.	*注释的内容要清楚、明了，含义准确，防止注释二义性。<br>	说明：错误的注释不但无益反而有害。<br>	<br>19.	*避免在注释中使用缩写，特别是不常用缩写。<br>	说明：在使用缩写时或之前，应对缩写进行必要的说明。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_4" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097213">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:54</span>&nbsp;&nbsp;</div>
			<div class="postText2">8.	类属性、公有和保护方法注释：写在类属性、公有和保护方法上面。<br>	示例：<br>	/**<br>	 * 注释内容<br>	 */<br>	private String logType;<br>	<br>	/**<br>	 * 注释内容<br>	 */<br>	public void write()<br>	<br>9.	成员变量注释内容：成员变量的意义、目的、功能，可能被用到的地方。<br>	<br>10.	公有和保护方法注释内容：列出方法的一句话功能简述、功能详细描述、输入参数、输出参数、返回值、违例等。<br>	格式：<br>	/**<br>	 * 〈一句话功能简述〉<br>	 * 〈功能详细描述〉<br>	 * @param [参数1]     [参数1说明]<br>	 * @param [参数2]     [参数2说明]<br>	 * @return  [返回类型说明]<br>	 * @exception/throws [违例类型] [违例说明]<br>	 * @see          [类、类#方法、类#成员]<br>	 * @deprecated<br>	 */<br>	说明：@since 表示从那个版本开始就有这个方法；@exception或throws 列出可能仍出的异常；@deprecated 表示不建议使用该方法。<br>	示例：<br>	    /**<br>	     * 根据日志类型和时间读取日志。<br>	     * 分配对应日志类型的LogReader， 指定类型、查询时间段、条件和反复器缓冲数，<br>	     * 读取日志记录。查询条件为null或0的表示没有限制，反复器缓冲数为0读不到日志。<br>	     * 查询时间为左包含原则，即 [startTime, endTime) 。<br>	     * @param logTypeName  日志类型名（在配置文件中定义的）<br>	     * @param startTime     查询日志的开始时间<br>	     * @param endTime      查询日志的结束时间<br>	     * @param logLevel      查询日志的级别<br>	     * @param userName     查询该用户的日志<br>	     * @param bufferNum    日志反复器缓冲记录数<br>	     * @return  结果集，日志反复器<br>	     * @since  CommonLog1.0 <br>	     */<br>	    public static LogIterator read(String logType, Date startTime,	Date endTime,<br>	                                   int logLevel, String userName, int bufferNum)<br>	<br>11.	对于方法内部用throw语句抛出的异常，必须在方法的注释中标明，对于所调用的其他方法所抛出的异常，选择主要的在注释中说明。 对于非RuntimeException，即throws子句声明会抛出的异常，必须在方法的注释中标明。<br>	说明：异常注释用@exception或@throws表示，在JavaDoc中两者等价，但推荐用@exception标注Runtime异常，@throws标注非Runtime异常。异常的注释必须说明该异常的含义及什么条件下抛出该异常。<br>	<br>12.	*注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_5" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097212">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:54</span>&nbsp;&nbsp;</div>
			<div class="postText2">5.	文件注释内容：版权说明、描述信息、生成日期、修改历史。<br>	说明：文件名可选。<br>	格式：<br>	/*<br>	 * 文件名：[文件名]<br>	 * 版权：〈版权〉<br>	 * 描述：〈描述〉<br>	 * 修改人：〈修改人〉<br>	 * 修改时间：YYYY-MM-DD<br>	 * 跟踪单号：〈跟踪单号〉<br>	 * 修改单号：〈修改单号〉<br>	 * 修改内容：〈修改内容〉<br>	 */<br>	<br>	说明：每次修改后在文件头部写明修改信息，CheckIn的时候可以直接把蓝色字体信息粘贴到VSS的注释上。在代码受控之前可以免去。<br>	<br>	示例：<br>	/*<br>	 * 文件名：LogManager.java<br>	 * 版权：Copyright 2000-2001 Huawei Tech. Co. Ltd. All Rights Reserved. <br>	 * 描述： WIN V200R002 WEBSMAP 通用日志系统<br>	 * 修改人： 张三<br>	 * 修改时间：2001-02-16<br>	 * 修改内容：新增<br>	 * 修改人： 李四<br>	 * 修改时间：2001-02-26<br>	 * 跟踪单号：D20103<br>	 * 修改单号：WSS368<br>	 * 修改内容：。。。。。。<br>	 * 修改人： 王五<br>	 * 修改时间：2001-03-25<br>	 * 跟踪单号：D27153<br>	 * 修改单号：WSS498<br>	 * 修改内容：。。。。。。<br>	 */<br>	<br>6.	类和接口的注释：该注释放在 package 关键字之后，class 或者 interface 关键字之前。<br>	说明：方便JavaDoc收集<br>	示例：<br>	package com.huawei.iin.websmap.comm;<br>	<br>	/**<br>	 * 注释内容<br>	 */<br>	public class CommManager<br>	<br>7.	类和接口的注释内容：类的注释主要是一句话功能简述、功能详细描述，<br>	说明：可根据需要列出：版本号、生成日期、作者、内容、功能、与其它类的关系等。 如果一个类存在Bug，请如实说明这些Bug。<br>	格式：<br>	/**<br>	 * 〈一句话功能简述〉<br>	 * 〈功能详细描述〉<br>	 * @author     [作者]<br>	 * @version   [版本号, YYYY-MM-DD]<br>	 * @see         [相关类/方法]<br>	 * @since      [产品/模块版本] <br>	 * @deprecated<br>	 */<br>	说明：描述部分说明该类或者接口的功能、作用、使用方法和注意事项，每次修改后增加作者和更新版本号和日期，@since 表示从那个版本开始就有这个类或者接口，@deprecated 表示不建议使用该类或者接口。<br>	示例：<br>	/**<br>	 * LogManager 类集中控制对日志读写的操作。<br>	 * 全部为静态变量和静态方法，对外提供统一接口。分配对应日志类型的读写器，<br>	 * 读取或写入符合条件的日志纪录。<br>	 * @author      张三，李四，王五<br>	* @version    1.2, 2001-03-25<br>	 * @see          LogIteraotor<br>	 * @see          BasicLog<br>	 * @since       CommonLog1.0 <br>	 */</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_6" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097211">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:54</span>&nbsp;&nbsp;</div>
			<div class="postText2">II.	注释规范<br>A.	规则<br>1.	一般情况下，源程序有效注释量必须在30％以上。<br>	说明：注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。可以用注释统计工具来统计。0<br>	<br>2.	包的注释：包的注释写入一个名为 package.html 的HTML格式的说明文件放入当前路径。<br>	说明：方便JavaDoc收集<br>	示例：<br>	com/huawei/iin/websmap/comm/package.html<br>	<br>3.	包的注释内容：简述本包的作用、详细描述本包的内容、产品模块名称和版本、公司版权。<br>	说明：在详细描述中应该说明这个包的作用以及在整个项目中的位置。<br>	格式：<br>	&lt;html&gt;<br>	&lt;body&gt;<br>	&lt;p&gt;一句话简述。<br>	&lt;p&gt;详细描述。<br>	&lt;p&gt;产品模块名称和版本<br>	&lt;br&gt;公司版权信息<br>	&lt;/body&gt;<br>	&lt;/html&gt;<br>	<br>	示例：<br>	&lt;html&gt;<br>	&lt;body&gt;<br>	&lt;P&gt;为 WEBSMAP 提供通信类，上层业务使用本包的通信类与 SMP-B 进行通信。<br>	&lt;p&gt;详细描述。。。。。。。。<br>	&lt;p&gt;IIN V100R001 WEBSMAP<br>	&lt;br&gt;(C) 版权所有 2000-2001 华为技术有限公司<br>	&lt;/body&gt;<br>	&lt;/html&gt;<br>	<br>4.	文件注释：文件注释写入文件头部，包名之前的位置。<br>	说明：注意以 /* 开始避免被 JavaDoc 收集<br>	示例：<br>	/*<br>	 * 注释内容<br>	 */<br>	package com.huawei.iin.websmap.comm;</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_7" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097210">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:54</span>&nbsp;&nbsp;</div>
			<div class="postText2">8.	*在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如.），后不应加空格。<br>	说明：采用这种松散方式编写代码的目的是使代码更加清晰。<br>	由于留空格所产生的清晰性是相对的，所以，在已经非常清晰的语句中没有必要再留空格，如果语句已足够清晰则括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在Java语言中括号已经是最清晰的标志了。<br>	在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。<br>	示例：<br>	(1) 逗号、分号只在后面加空格。<br>	int a, b, c; <br>	<br>	(2)比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&amp;&amp;"、"&amp;"，位域操作符"&lt;&lt;"、"^"等双目操作符的前后加空格。<br>	if (current_time &gt;= MAX_TIME_VALUE) <br>	a = b + c;<br>	a *= 2;<br>	a = b ^ 2;<br>	<br>	(3)"!"、"~"、"++"、"--"、"&amp;"（地址运算符）等单目操作符前后不加空格。<br>	flag = !isEmpty; // 非操作"!"与内容之间<br>	i++;             // "++","--"与内容之间<br>	<br>	(4)"."前后不加空格。<br>	p.id = pid;     // "."前后不加空格<br>	<br>	(5) if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。<br>	if (a &gt;= b &amp;&amp; c &gt; d)<br>	<br>B.	建议<br>1.	类属性和类方法不要交叉放置，不同存取范围的属性或者方法也尽量不要交叉放置。<br>	格式：<br>	类定义<br>	{<br>	    类的公有属性定义<br>	    类的保护属性定义<br>	    类的私有属性定义<br>	    类的公有方法定义<br>	    类的保护方法定义<br>	    类的私有方法定义<br>	}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_8" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097208">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:54</span>&nbsp;&nbsp;</div>
			<div class="postText2">4.	*不允许把多个短语句写在一行中，即一行只写一条语句<br>	示例：如下例子不符合规范。<br>	        LogFilename now = null;        LogFilename that = null;<br>	应如下书写<br>	        LogFilename now = null;<br>	        LogFilename that = null;<br>	<br>5.	*if, for, do, while, case, switch, default 等语句自占一行，且if, for, do, while等语句的执行语句无论多少都要加括号{}。<br>	示例：如下例子不符合规范。<br>	        if(writeToFile)           writeFileThread.interrupt();<br>	<br>	应如下书写：<br>	        if(writeToFile)<br>	        {<br>	            writeFileThread.interrupt();<br>	        }<br>	<br>6.	*相对独立的程序块之间、变量说明之后必须加空行。<br>	示例：如下例子不符合规范。<br>	        if(log.getLevel() &lt; LogConfig.getRecordLevel())<br>	        {<br>	            return;<br>	        }<br>	        LogWriter writer;<br>	<br>	应如下书写<br>	        if(log.getLevel() &lt; LogConfig.getRecordLevel())<br>	        {<br>	            return;<br>	        }<br>	<br>	        LogWriter writer;<br>	        int index;<br>	<br>7.	*对齐只使用空格键，不使用TAB键。<br>	说明：以免用不同的编辑器阅读程序时，因TAB键所设置的空格数目不同而造成程序布局不整齐。JBuilder、UltraEdit等编辑环境，支持行首TAB替换成空格，应将该选项打开。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_9" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097207">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 09:53</span>&nbsp;&nbsp;</div>
			<div class="postText2">I.	排版规范<br>A.	规则<br>1.	*程序块要采用缩进风格编写，缩进的空格数为4个。<br>	说明：对于由开发工具自动生成的代码可以有不一致。<br>	<br>2.	*分界符（如大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类和接口的定义、以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。<br>	示例：如下例子不符合规范。<br>	for (...) {<br>	    ... // program code<br>	}<br>	<br>	if (...) <br>	    {<br>	    ... // program code<br>	    }<br>	<br>	void example_fun( void )<br>	    {<br>	    ... // program code<br>	    }<br>	<br>	应如下书写。<br>	for (...) <br>	{<br>	    ... // program code<br>	}<br>	<br>	if (...) <br>	{<br>	    ... // program code<br>	}<br>	<br>	void example_fun( void )<br>	{<br>	    ... // program code<br>	}<br>	<br>3.	*较长的语句、表达式或参数（&gt;80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。<br>	示例：<br>	if (filename != null <br>	    &amp;&amp; new File(logPath + filename).length() &lt; LogConfig.getFileSize())<br>	{<br>	    ... // program code<br>	}<br>	<br>	public static LogIterator read(String logType, Date startTime,	Date endTime,<br>	                                                int logLevel, String userName, int bufferNum)</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_10" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086435">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 16:03</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议29	字符串大小写转换时，应加上Locale.US<br>说明：String类的toUpperCase()和toLowerCase()方法，如果不输入参数，则会按当前系统默认的编码模式转换，因此转换结果可能并非如你所预期，如下所示：<br>示例：<br>	不好：如果当前环境是土耳其Turkish，那最后输出的结果不是预期的大写I了，而是另外一个字符（İ）<br>String testString = "i";		<br>System.out.println(testString.toUpperCase());<br>推荐：字符串的大小写转换一般都是在26个英文字母，建议显示指定语言为Local.US<br>String testString = "i";		<br>System.out.println(testString.toUpperCase(Local.US));</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_11" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086431">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 16:01</span>&nbsp;&nbsp;</div>
			<div class="postText2">10	国际化<br>规则67	在所有的输入输出环节，指明正确的编码方式，进行正确的字符到字节，或字节到字符的转换<br>说明：见如下示例<br>String newStr = new String(oldStr.getBytes("GBK"), "UTF-8");   <br>规则68	如果输入源或输出目标直接支持，尽可能直接使用Unicode进行输入输出。<br>说明：例如，Oracle数据库直接支持UTF-8的文本数据。使用UTF-8操作Oracle，可自动兼容所有的语言文字；反之，使用ISO-8859-1或者ASCII去操作Oracle，只能兼容欧美单字节的文字。<br><br>规则69	不要依赖平台默认的字符编码方式。<br>说明：例如，中文Windows下，默认的编码为GBK，英文linux下，默认编码为ISO-8859-1。依赖平台默认值意味着同样的程序在不同的平台上可能产生不同的结果。<br><br>规则70	对于使用默认编码方式的第三方代码或者遗留代码，可应用适配器模式，将返回的字符串转换成Unicode内码<br>说明：例如，我们的数据库错误的使用了ASCII编码存储文本，也就是说从数据库返回的中文字，实际上被“拆”成了两个欧洲字符。但是数据库中已经保存了大量数据，全改成Unicode表示不容易。我们可以在数据访问层做一个适配器，将欧洲字符重新组合，变成真正的Unicode中文。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_12" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086429">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 16:01</span>&nbsp;&nbsp;</div>
			<div class="postText2">9	可移植性<br>规则66	不要在代码中硬编码"\n"和"\r"作为换行符号<br>说明：回车换行符在不同操作系统下是有区别的，如果需要换行，尽量用println来代替在字符串中使用"\n"。也可以使用System.getProperty("line.separator")获取运行时环境的换行符。<br>示例：<br>不好<br>System.out.print("Hello,world!\n");<br>推荐<br>System.out.println("Hello,world!");<br>建议27	谨慎地使用本地方法<br>说明：Java中的本地方法，最早用来解决下面三种场景的使用：<br>1、提供平台特定的能力访问（如Windows平台下的注册表或文件锁）；<br>2、提供对遗留库或数据的访问（如遗留库使用C/C++实现等情况）；<br>3、为了提高应用程序部分代码的性能；<br>但是，随着Java技术的发展，以上问题在新的JDK版本中都已经得到解决，从JDK 1.3开始，已经不再建议使用本地方法；它会导致应用程序与具体的OS平台耦合，会降低程序的通用性，并且因为实现方面的问题，通常会导致应用程序阻塞、死锁、崩溃等不稳定现象；而且，代码的可读性及可维护性也将大大降低，总而言之，在使用本地方法之前请务必三思。<br><br>建议28	避免对第三方代码的强依赖或陷入第三方代码细节<br>说明：程序中无可避免的会使用第三方提供的代码/jar包，而这些第三方的代码/jar包所提供的接口，是我们无法控制的，即使是公司/部门内部提供的接 口，因此，当程序中（大量）使用了第三方提供的代码/jar包时，可以使用Adapter模式，封装中间层，以避免第三方的变更对已有程序的影响。例如：公司从今年开始取消iLog，使用自研的netGo替换，而我们在代码中大量使用了iLog对象进行交互，替换过程难免艰难，也容易引入问题，如果当初在代码中能对iLog对象进行封装，在替换时就不会影响逻辑代码。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_13" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086427">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 16:00</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则63	将对象存入HashSet，或作为key存入HashMap(或HashTable)后，必须确保该对象的hashcode值不变，避免因为hashcode值变化导致不能从集合内删除该对象，进而引起内存泄露的问题<br>说明：对于Hash集合(HashMap，HashSet等)而言，对象的hashcode至关重要，在hash集合内查找该对象完全依赖此值。如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄露。<br>示例：<br>	错误的示例<br>public class Email {<br>	public String address;<br>	<br>	public Email(String address) {<br>		this.address = address;<br>	}<br>	<br>	public int hashCode() { <br>		int result = address.hashCode(); <br>		return result; <br>	} <br>	<br>	public static void main(String[] args) {<br>		HashSet&lt;Email&gt; set = new HashSet&lt;Email&gt;(); <br>		Email email = new Email("huawei.com"); <br>		set.add(email); <br>		<br>		email.address = "silong.com"; //修改地址值，导致hashcode值变化 ...... <br>		<br>		System.out.println(set.contains(email)); //false<br>		set.remove(email); //leak<br>	}<br>}<br>规则64	执行IO操作时，应该在finally里关闭IO资源<br>说明：申请的资源不使用时，都要释放。而在产生异常时，资源释放常被忽视。因此要求在数据库操作、IO操作等需要显示使用方法如close()释放资源时，必须在try -catch-finally的finally中close()。如果有多个IO对象需要close()，需要分别对每个对象的close()方法进行try-catch，防止一个IO对象关闭失败其他IO对象都未关闭。保证产生异常时释放已申请的资源。<br>示例：<br>try {<br>	in = new FileInputStream(inputFileName);<br>	out = new FileOutputStream(outputFileName);<br>	copy(in, out);<br>} finally {<br>	close(in);<br>	close(out);<br>}<br>...<br>public static void close(Closeable c) {<br>	if (c == null)<br>		return;<br>	try {<br>		c.close();<br>	} catch (IOException e) {<br>		// log the exception<br>	}<br>}<br>规则65	消除过期的对象引用<br>说明：过期引用是指永远也不会再被解除的引用。在支持垃圾回收的语言中，内存泄露是很隐蔽的。如果一个对象引用被无意识地保留起来，那么，垃圾回收机制不仅不会处理这个对象，而且也不会处理被这个对象所引用的所有其他对象。<br>例如：如下是Stack类的pop方法。被弹出的对象，不会被垃圾回收机制回收，即使使用Stack的程序不再引用被弹出的对象，也不会回收。因为，Stack内部仍维护着对这些对象的过期引用。<br>public Object pop() {<br>		if (size == 0) {<br>			throw new EmptyStackException();		<br>		}<br>		return elements[--size];<br>	}<br>改为如下，则可消除过期引用<br>public Object pop() {<br>		if (size == 0) {<br>			throw new EmptyStackException();		<br>		}<br>		Object result = elements[--size];<br>		elements[size] = null;<br>		return result;<br>	}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_14" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086416">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:55</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议26	在Java的IO操作中，尽量使用带缓冲的实现<br>说明：在Java的IO操作，读写操作都有两套实现，一套是没有实现缓冲的，一套是实现了内容缓冲的，使用带有缓冲功能的IO操作，可以降低存储介质的访问次数，从而提高数据读写的效率，提供更好的操作性能。因此，建议使用带有缓冲功能的实现来进行IO操作。<br>对于性能要求更高的实现，可以使用Java NIO<br>示例：<br>	不好<br>PrintWriter out = null;<br>	try {<br>		out = new PrintWriter("file.txt");<br>		String line = null;<br>		for (int i = 0; i &lt; 100; i++) {<br>			// write content<br>			out.println("write  content  " + i);<br>		}<br>	} finally {<br>		IOUtils.close(out);<br>	}<br>推荐<br>PrintWriter out = null;<br>try {<br>	out = new PrintWriter(new BufferedWriter(new FileWriter("file.txt")));<br>	String line = null;<br>	for (int i = 0; i &lt; 100; i++) {<br>		// write content<br>		out.println("write  content  " + i);<br>	}<br>} finally {<br>	IOUtils.close(out);<br>}<br>8.2	资源管理<br>规则62	避免创建不必要的对象<br>说明：重用一个已经创建的对象比创建一个新的对象要好得多，除非确实需要重新创建。创建重复不必要的对象会导致资源浪费，严重时可能会导致性能问题。<br>示例：<br>不好：<br>String s = new String("string");<br>推荐：<br>String s = "string";</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_15" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086412">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:53</span>&nbsp;&nbsp;</div>
			<div class="postText2">8	性能与资源管理<br>8.1	性能<br>原则17	谨慎地进行性能优化<br>说明：优化的弊大于利，特别是不成熟的优化。在优化的过程中，产生的软件可能既不快速，也不正确，而且还不容易修正。不要因为性能而牺牲合理的结构。要努力编写好的程序而不是快的程序。如果好的程序不够快，它的良好结构可以是它可以得到更加便利的优化。好的程序体现了信息隐藏（information hiding）的原则：只要有可能，它们就会把设计决策集中在单个模块中，因此，可以改变单个决策，而不会影响到系统的其他部分。<br>这并不意味着，在完成程序之前就可以忽略性能问题。实现上的问题可以通过后期的优化而得到修正。但是，遍布全局并且限制性能的结构缺陷几乎是不可能被改正的，除非重新系统。在系统完成之后再改变设计的某个基本方法，会导致系统的结构很不好，从而难以维护和改进。因此，必须在设计过程中考虑的性能问题<br><br><br>规则60	使用System.arraycopy()进行数组复制<br>说明：在将一个数组对象复制成另外一个数组对象时，请不要自己使用循环复制，可以使用JAVA提供的System.arraycopy()功能来复制数据对象，这样做可以避免出错，而且效率会更高。<br>示例：<br>	不好<br>int[] src = { 1, 2, 3, 4, 5 };<br>int[] dest = new int[5];<br>for (int i = 0; i &lt; 5; i++) {<br>	dest[i] = src[i];<br>}<br>推荐<br>int[] src = { 1, 2, 3, 4, 5 };<br>int[] dest = new int[5];<br>System.arraycopy(src, 0, dest, 0, 5);<br>规则61	使用集合的toArray()方法将集合转为数组（v1.42+）<br>说明：更好的性能，代码更加简洁<br>示例：<br>ArrayList list = new ArrayList();<br>list.add....<br>String [] array = new String[list.size()];<br>list.toArray(array);</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_16" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086410">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:52</span>&nbsp;&nbsp;</div>
			<div class="postText2">类（value classes）的设计，可考虑实现Comaprable接口，方便在集合中实现对象的搜索、排序、计算极值等<br>说明：一旦类实现了Comparable接口，它就可以跟很多泛型算法以及依赖于该接口的集合实现进行协作。你付出很小的努力就可以获得非常强大的功能。事实上，Java平台类库中的所有值类（value classes）都实现了Comparable接口。如果你正在编写一个值类，它具有非常明显的内在排序关系，比如按字母顺序、按数值顺序或者按年代顺序，那你就应该坚决考虑实现这个接口。<br>public interface Comparable&lt;T&gt; {<br>	int compareTo(T t);<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_17" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086408">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:52</span>&nbsp;&nbsp;</div>
			<div class="postText2">7.5	其他语言特性<br><br>规则58	使用JDK自带的API或广泛使用的开源库，不要自己写类似的功能。<br>说明：JDK和开源库（例如Apache Commons,Google Guava等）已实现的功能，不要重复实现，避免造成浪费。<br><br>规则59	新代码不要使用已标注为@deprecated的方法<br>说明：标注为@deprecated的方法，是由于各种原因被JDK废弃的方法，为了保持兼容性而没有删除，新写的代码应避免使用这些方法，而应该使用JDK推荐的代替方法。<br><br>建议22	升级到最新的Java 平台版本上，以便获取新特性带来的收益<br>说明：较新的版本都包含许多让程序员更轻松的改进，你并不需要费力去学习怎样利用所有的新特性，有些新特性不需要你付出任何努力就可以给你带来实惠。<br><br>建议23	充分利用编译器的告警选项<br>在C/C++中一条被普遍了解的规则是将编译器告警级别调整至最高并保持告警清零。在Java中该动作通常由静态检查工具如findbugs等完成，而现在一些IDE也增加了很多有价值的告警信息（例如eclipse中对null指针的分析），将尽可能多的告警选项打开并保持告警正确清零，也有助于代码质量的提高。需要注意的是告警选项缺省情况下未必保存在工程文件中，为了整个团队使用一致的告警选项，需要将之配置到工程中。<br><br>建议24	使用字符串API时，应注意方法使用的是否是 “正则表达式”<br>说明：正则表达式所引发的问题趋向于在运行时刻而不是在编译时刻暴露出来。如，String.replaceAll()方法第一个参数接受的是一个正则表达式，当匹配'.'符号时，需使用\\.进行转义。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_18" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086406">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:52</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议20	方法的设计可优先考虑泛型（v1.5+）<br>说明：就如类可以从泛型中受益一般，方法也一样。静态工具方法尤其适合于泛型化。<br>示例：如下所示，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也更加容易。<br>public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) {<br>	Set&lt;E&gt; result = new HashSet&lt;E&gt;(s1);<br>	result.addAll(s2);<br>	return result;<br>}<br>	<br>public static void main(String[] args) {<br>	Set&lt;String&gt; guys = new HashSet&lt;String&gt;(Arrays.asList("Tom", "Dick", "Harry"));<br>	Set&lt;String&gt; stooges = new HashSet&lt;String&gt;(Arrays.asList("Larry", "Moe", "Curly"));<br>	Set&lt;String&gt; aflCio = union(guys, stooges);<br>	System.out.println(aflCio);<br>}<br>建议21	优先使用泛型集合，而不是数组（v1.5+）<br>说明：数组与泛型集合相比，有两个重要不同点。首先，数组是协变的(covariant)，即Sub是Super的子类型，则Sub[]也是Super[]的子类型。相反，泛型则是不可变的(invariant)，对于任意两个类型Type1和Type2，List&lt;Type1&gt;既不是List&lt;Type2&gt;的子类型，也不是其超类型。其次，数组是具体化的，因此数组在运行时才知道并检查它们的元素类型约束。<br>示例：如下代码是合法的，但执行时会报错<br>Object[] objectArray = new Long[1];<br>objectArray[0] = "I don't fit in"; //Throws ArrayStoreException<br>而如下代码则会在编译时报错<br>List&lt;Object&gt; objectList = new ArrayList&lt;Long&gt;(); //Incompatible types<br>objectList.add("I don't fit in");</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_19" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086405">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 15:51</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议18	实现Serializable接口的可序列化类应该显式声明 serialVersionUID<br>说明： 如果可序列化类未显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID 值，如“Java(TM) 对象序列化规范”中所述。不过，强烈建议所有可序列化类都显式声明 serialVersionUID 值，原因计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。因此，为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。还强烈建议使用 private 修改器显示声明 serialVersionUID（如果可能），原因是这种声明仅应用于立即声明类 – serialVersionUID 字段作为继承成员没有用处。<br>示例：<br>public class BeanType implements Serializable<br>{<br>    private static final long serialVersionUID = -2589766491699675794L;<br>    …<br>}<br>7.4	泛型<br>规则57	在集合中使用泛型（v1.5+）<br>说明：Java 1.5版本中增加了泛型，在没有泛型之前，从集合中读取到的每一个对象都必须进行转换。如果有人不小心插入类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。<br>示例：<br>	不好：错误的将Coin对象插入到samps集合中，直到从集合中获取coin时才收到错误提示<br>private final Collection stamps = ...;<br><br>stamps.add(new Coin(...));<br>推荐：使用泛型，在编译时会提示类型错误<br>rivate final Collection&lt;Stamp&gt; stamps = ...;<br><br>stamps.add(new Coin(...));<br>还有个好处是，从集合中获取元素时，不再需要进行手工类型转换。如下所示：<br>for(Stamp s : stamps) {<br>	...<br>}<br>建议19	类的设计可优先考虑泛型（v1.5+）<br>说明：使用泛型类型，比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。<br>示例：如下所示，一个设计为泛型的stack类，在使用时，无需对栈中元素进行类型转换。<br>public static void main(String[] args) {<br>		Stack&lt;String&gt; stack = new Stack&lt;String&gt;();<br>		for (String arg : args)<br>			stack.push(arg);<br>		while(!stack.isEmpty())<br>			System.out.println(stack.pop().toUpperCase());<br>	}</div>				
		</div>
	<div class="line"></div>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;3&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">下一页</a>&nbsp;
</div></div>
</div>


			</td>
		</tr>
		</tbody></table>
	</td>
	<td width="10">&nbsp;</td>
	<td valign="top">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
			<table width="100%" height="200">
			<tbody><tr>
				<td><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/09/01&#39;);return false;">&lt;</a></td><td align="center">2018年10月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/11/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td class="CalWeekendDay" align="center">6</td></tr><tr><td class="CalWeekendDay" align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td class="CalWeekendDay" align="center">13</td></tr><tr><td class="CalWeekendDay" align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalWeekendDay" align="center">20</td></tr><tr><td class="CalWeekendDay" align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">24</td><td align="center">25</td><td align="center">26</td><td class="CalWeekendDay" align="center">27</td></tr><tr><td class="CalWeekendDay" align="center">28</td><td align="center">29</td><td align="center">30</td><td align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></td>
			</tr>
			</tbody></table>
				
<h1>&nbsp;公告</h1><br>
<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/chenyankai/">hunyihun</a><br>园龄：<a href="https://home.cnblogs.com/u/chenyankai/" title="入园时间：2013-11-13">4年10个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/chenyankai/followers/">0</a><br>关注：<a href="https://home.cnblogs.com/u/chenyankai/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;bb2fa9a6-374c-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('bb2fa9a6-374c-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
	
				
<h1>&nbsp;导航</h1>
<ul class="list" type="square">
	<li class="listitem"><a id="blog_nav_sitehome" class="listitem" href="https://www.cnblogs.com/">博客园</a></li>
	<li class="listitem"><a id="blog_nav_myhome" class="listitem" href="https://www.cnblogs.com/chenyankai/">首页</a></li>
	<li class="listitem"><a id="blog_nav_newpost" class="listitem" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">发新随笔</a></li>
	<li class="listitem"><a id="MyLinks1_NewArticleLink" class="listitem" href="https://www.cnblogs.com/EnterMyBlog.aspx?NewArticle=1">发新文章</a></li>
	<li class="listitem"><a id="blog_nav_contact" accesskey="9" class="listitem" rel="nofollow" href="https://msg.cnblogs.com/send/hunyihun">联系</a></li>
	<li class="listitem"><a id="blog_nav_rss" class="listitem" href="https://www.cnblogs.com/chenyankai/rss">订阅</a><a id="blog_nav_rss_image" href="https://www.cnblogs.com/chenyankai/rss"><img src="./最新评论 - hunyihun - 博客园3_files/xml.gif" alt="订阅"></a>
	</li><li class="listitem"><a id="blog_nav_admin" class="listitem" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

				<div id="blog_stats">
<h1>&nbsp;统计</h1>
	<ul class="list" type="square">
		<li class="listitem">随笔： 2
		</li><li class="listitem">文章： 0
		</li><li class="listitem">评论： 155
		</li><li class="listitem">引用： 0
	</li>
</ul></div>
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/chenyankai/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="https://www.cnblogs.com/chenyankai/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="https://www.cnblogs.com/chenyankai/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">

</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
		<h1 class="listtitle">随笔档案</h1>
		
				<ul class="list" type="square">
			
				<li class="listitem"><a id="CatList_LinkList_0_Link_0" class="listitem" href="https://www.cnblogs.com/chenyankai/archive/2014/09.html">2014年9月 (2)</a> </li>
			
				</ul>
			
	
</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<h3 class="catListTitle">最新评论</h3>
<div class="RecentComment" id="RecentComments">
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097337">1. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">使用强随机数说明：安全敏感的代码块（如SessionID的生成、挑战算法中的随机数生成等），必须采用强随机数，禁止使用伪随机数。Java API 提供了伪随机数生成器（PRNG）——java.util......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097329">2. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">原则7.3 基于哈希算法的口令安全存储必须加入盐值（salt）说明：单向哈希是在一个方向上工作的哈希函数，从预映射的值很容易计算其哈希值，但要根据特定哈希值产生一个预映射的值却是非常困难的。单向哈希主......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097327">3. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">7.	其它原则7.1 禁止在日志中保存口令、密钥说明： 在日志中不能保存口令和密钥，其中的口令包括明文口令和密文口令。对于敏感信息建议采取以下方法，1）不打印在日志中；2）若因为特殊原因必须要打印日志......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097326">4. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">避免依赖和信任环境变量说明：使用环境变量会带来可以移植性问题，在不同的操作系统中其语义可能有所不同。因此要尽量避免使用环境变量。对于一个值如果有定义的系统属性(System properties)可用......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097325">5. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">所有安全相关的敏感代码都放在一个jar包中，并签名再加密说明：若安全相关的敏感代码（例如进行权限控制或者用户名密码校验的代码）没有放到同一个受信任的jar包中，攻击者可以通过先加载恶意代码（使用相同的......</li>
        <li class="recent_comment_author">--hunyihun</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<h3 class="catListTitle">阅读排行榜</h3>
<div class="RecentComment" id="TopViewPosts"> 
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(67)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(15)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<h3 class="catListTitle">评论排行榜</h3>
<div class="RecentComment" id="TopCommentsPosts">
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(97)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(58)</a></li></ul></div>
</div></div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap" style="display: none;">
<h3 class="catListTitle">推荐排行榜</h3>
<div class="RecentComment">
	<div id="TopDiggPostsBlock"></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			<br>
			
<div class="footer">
	Powered by: <a href="http://www.cnblogs.com/">博客园</a><br>模板提供：<a href="http://blog.hjenglish.com/">沪江博客</a><br>
	Copyright ©2018 hunyihun
</div>
			</td>
		</tr>
		</tbody></table>
	</td>
</tr>
</tbody></table>
<br>



</body></html>