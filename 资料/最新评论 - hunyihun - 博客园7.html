<!DOCTYPE html>
<!-- saved from url=(0061)https://www.cnblogs.com/chenyankai/recentcomments.html?page=7 -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<title>最新评论 - hunyihun - 博客园</title>
<link type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园7_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园7_files/bundle-classic.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园7_files/bundle-classic-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/chenyankai/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/chenyankai/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/chenyankai/wlwmanifest.xml">
<script async="" src="./最新评论 - hunyihun - 博客园7_files/analytics.js.下载"></script><script src="./最新评论 - hunyihun - 博客园7_files/jquery-2.2.0.min.js.下载"></script>
<script type="text/javascript">var currentBlogApp = 'chenyankai', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./最新评论 - hunyihun - 博客园7_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<table align="center" width="98%" cellspacing="0" cellpadding="0" border="0" style="margin-top:10px">
<tbody><tr>
	<td valign="top" width="70%" style="padding:0">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
<div id="header">
	<span>
		<a id="Header1_HeaderTitle" href="https://www.cnblogs.com/chenyankai/">hunyihun</a><br>
		<div class="sub"></div>
	</span>
</div>
			</td>
		</tr>
		</tbody></table>
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white" class="index">
		<tbody><tr>
			<td class="main">
			

<div id="myposts">
<h3 class="myposts_title">最新评论</h3>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;7&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">下一页</a>&nbsp;
</div></div>

		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_0" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086101">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:28</span>&nbsp;&nbsp;</div>
			<div class="postText2">推荐做法：先签名后加密<br>public static void main(String[] args) throws IOException, GeneralSecurityException, ClassNotFoundException<br>{<br>    // Build map <br>    SerializableMap&lt;String, Integer&gt; map = buildMap();<br>    // Generate signing public/private key pair &amp; sign map<br>    KeyPairGenerator kpg = KeyPairGenerator.getInstance("DSA");<br>    KeyPair kp = kpg.generateKeyPair();<br>    Signature sig = Signature.getInstance("SHA1withDSA");<br>    SignedObject signedMap = new SignedObject(map, kp.getPrivate(), sig);<br>    // Generate sealing key &amp; seal map <br>    KeyGenerator generator;<br>    generator = KeyGenerator.getInstance("AES");<br>    generator.init(new SecureRandom());<br>    Key key = generator.generateKey();<br>    Cipher cipher = Cipher.getInstance("AES");<br>    cipher.init(Cipher.ENCRYPT_MODE, key);<br>    SealedObject sealedMap = new SealedObject(signedMap, cipher);<br>    // Serialize map <br>    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(<br>                "data"));<br>    out.writeObject(sealedMap);<br>    out.close();<br>    // Deserialize map <br>    ObjectInputStream in = new ObjectInputStream(new FileInputStream("data")); <br>    sealedMap = (SealedObject) in.readObject();<br>    in.close();<br>    // Unseal map cipher = Cipher.getInstance("AES"); <br>    cipher.init(Cipher.DECRYPT_MODE, key);<br>    signedMap = (SignedObject) sealedMap.getObject(cipher);<br>    // Verify signature and retrieve map <br>    if (!signedMap.verify(kp.getPublic(), sig))<br>    {<br>        throw new GeneralSecurityException("Map failed verification");<br>    }<br>    map = (SerializableMap&lt;String, Integer&gt;) signedMap.getObject();<br>    // Inspect map <br>    InspectMap(map);<br>}<br>先签名后加密，既能保证数据的真实可靠性，又能防止“中间人攻击”(man-in-middle attacks)。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_1" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086099">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:27</span>&nbsp;&nbsp;</div>
			<div class="postText2">错误示例3：先加密后签名<br>public static void main(String[] args) throws IOException, GeneralSecurityException, ClassNotFoundException<br>{<br>    // Build map<br>    SerializableMap&lt;String, Integer&gt; map = buildMap();<br>    // Generate sealing key &amp; seal map<br>    KeyGenerator generator;<br>    generator = KeyGenerator.getInstance("AES");<br>    generator.init(new SecureRandom());<br>    Key key = generator.generateKey();<br>    Cipher cipher = Cipher.getInstance("AES");<br>    cipher.init(Cipher.ENCRYPT_MODE, key);<br>    SealedObject sealedMap = new SealedObject(map, cipher);<br>    // Generate signing public/private key pair &amp; sign map<br>    KeyPairGenerator kpg = KeyPairGenerator.getInstance("DSA");<br>    KeyPair kp = kpg.generateKeyPair();<br>    Signature sig = Signature.getInstance("SHA1withDSA");<br>    SignedObject signedMap = new SignedObject(sealedMap, kp.getPrivate(), sig);<br>        // Serialize map<br>    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("data"));<br>    out.writeObject(signedMap);<br>    out.close();<br>    // Deserialize map<br>    ObjectInputStream in = new ObjectInputStream(new FileInputStream("data"));<br>    signedMap = (SignedObject) in.readObject();<br>    in.close();<br>    // Verify signature and retrieve map<br>    if (!signedMap.verify(kp.getPublic(), sig))<br>    {<br>        throw new GeneralSecurityException("Map failed verification");<br>    }<br>    sealedMap = (SealedObject) signedMap.getObject();<br>    // Unseal map<br>    cipher = Cipher.getInstance("AES");<br>    cipher.init(Cipher.DECRYPT_MODE, key);<br>    map = (SerializableMap&lt;String, Integer&gt;) sealedMap.getObject(cipher);<br>    // Inspect map<br>    InspectMap(map);<br>}<br>这段代码先对数据进行加密，然后再对加密后的数据进行签名。这样做无法保证签名来自数据的原始来源。任何恶意的第三方可以截获原始加密签名后的数据，剔除原始的签名，并对密封的数据加上自己的签名。这样的话，即使恶意第三方无法获取原始的数据内容，正常的接收者也无法得到原始的数据。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_2" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086098">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:27</span>&nbsp;&nbsp;</div>
			<div class="postText2">本规则的错误示例代码和推荐做法都是基于下面的代码来说明:<br>class SerializableMap&lt;K, V&gt; implements Serializable<br>{<br>    final static long serialVersionUID = -2648720192864531932L;<br>    <br>    private Map&lt;K, V&gt; map;<br>    <br>    public SerializableMap()<br>    {<br>        map = new HashMap&lt;K, V&gt;();<br>    }<br>    <br>    public Object getData(K key)<br>    {<br>        return map.get(key);<br>    }<br>    <br>    public void setData(K key, V data)<br>    {<br>        map.put(key, data);<br>    }<br>}<br><br>public class MapSerializer<br>{<br>    public static SerializableMap&lt;String, Integer&gt; buildMap()<br>    {<br>        SerializableMap&lt;String, Integer&gt; map = new SerializableMap&lt;String, Integer&gt;();<br>        map.setData("John Doe", new Integer(123456789));<br>        map.setData("Richard Roe", new Integer(246813579));<br>        return map;<br>    }<br>    <br>    public static void InspectMap(SerializableMap&lt;String, Integer&gt; map)<br>    {<br>        System.out.println("John Doe's number is " + map.getData("John Doe"));<br>        System.out.println("Richard Roe's number is "<br>                + map.getData("Richard Roe"));<br>    }<br>    <br>    public static void main(String[] args)<br>    {<br>        // ... <br>    }<br>}<br>错误示例1：未做任何安全防护<br>public static void main(String[] args) throws IOException,<br>    ClassNotFoundException<br>{<br>    // Build map<br>    SerializableMap&lt;String, Integer&gt; map = buildMap();<br>    // Serialize map<br>    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("data"));<br>    out.writeObject(map);<br>    out.close();<br>    // Deserialize map<br>    ObjectInputStream in = new ObjectInputStream(new FileInputStream("data"));<br>    map = (SerializableMap&lt;String, Integer&gt;) in.readObject();<br>    in.close();<br>    // Inspect map<br>    InspectMap(map);      <br>}<br>错误示例2：只加密<br>public static void main(String[] args) throws IOException,<br>        GeneralSecurityException, ClassNotFoundException<br>{<br>    // Build map<br>    SerializableMap&lt;String, Integer&gt; map = buildMap();<br>    // Generate sealing key &amp; seal map<br>    KeyGenerator generator;<br>    generator = KeyGenerator.getInstance("AES");<br>    generator.init(new SecureRandom());<br>    Key key = generator.generateKey();<br>    Cipher cipher = Cipher.getInstance("AES");<br>    cipher.init(Cipher.ENCRYPT_MODE, key);<br>    SealedObject sealedMap = new SealedObject(map, cipher);<br>    // Serialize map<br>    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("data"));<br>    out.writeObject(sealedMap);<br>    out.close();<br>    // Deserialize map<br>    ObjectInputStream in = new ObjectInputStream(new FileInputStream("data"));<br>    sealedMap = (SealedObject) in.readObject();<br>    in.close();<br>    // Unseal map<br>    cipher = Cipher.getInstance("AES");<br>    cipher.init(Cipher.DECRYPT_MODE, key);<br>    map = (SerializableMap&lt;String, Integer&gt;) sealedMap.getObject(cipher);<br>    // Inspect map<br>    InspectMap(map);<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_3" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086095">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:26</span>&nbsp;&nbsp;</div>
			<div class="postText2">4.	序列化<br>原则4.1 敏感对象发送出信任区域前进行签名并加密<br>说明：敏感数据传输过程中要防止窃取和非法篡改。使用安全的加密算法给数据加密可以防止数据被窃取。而对数据加上数字签名则可以防止数据被非法篡改。在以下场景中，需要加密和数字签名的机制保证数据安全：<br>1）序列化或传输敏感数据；<br>2）无SSL传输通道或者代价太高；<br>3）敏感数据需要长久保存；<br>应该要避免使用私有加密算法，以免引入更多的漏洞。应用程序在readObject()和writeObject()方法中使用私有加密算法是典型的反例。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_4" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086093">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:26</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议3.3 避免让外部进程阻塞在输入输出流上<br>说明：java.lang.Runtime.exe()方法以及java.lang.ProcessBuilder.start()方法可以被用来调用外部程序,并使用java.lang.Proccess对象来表示该程序。Proccess对象使用三种流对象来与外部的程序进行交互：一个OutputStream对象用来给外部程序提供输入，一个InputStream对象用来接收外部程序的输出，以及一个InputStream对象来接收外部程序的错误信息。 一个外部进程可能需要输入信息（通过Proccess.getOutputStream()输入），也可能会输出信息或错误（通过Proccess.getInputStream()或者Proccess.getErrorStream()获取）。不正确的使用和处理外部进程的输入输出可能导致未知的异常、DoS以及其他安全问题。一个试图读取输入的外部进程会一直阻塞直到向其提供输入，调用这样的外部进程时必须对其提供输入。当一个外部进程通过其输出流对外输出信息或错误时，必须及时清空其输出流，以防止输出流中的缓冲区被耗尽而导致外部进程被阻塞。<br>错误示例1：<br>public class Exec<br>{<br>    public static void main(String args[]) throws IOException<br>    {<br>        Runtime rt = Runtime.getRuntime();<br>        Process proc = rt.exec("notemaker");<br>        int exitVal = proc.exitValue();<br>    }<br>}<br>上面的代码未等待外部程序终止就调用exitValue()会导致IllegalThreadStateException。<br>错误示例2:<br>public class Exec<br>{<br>    public static void main(String args[]) throws IOException,<br>            InterruptedException<br>    {<br>        Runtime rt = Runtime.getRuntime();<br>        Process proc = rt.exec("notemaker");<br>        int exitVal = proc.waitFor();<br>    }<br>}<br>上面的代码中使用waitFor()方法等待notemaker进程终止，防止出现上例中的IllegalThreadStateException. 但是它忽略了notemaker进程输出流或者错误流中的输出，这会导致两者的缓冲区被耗尽，从而使notemaker进程被阻塞，由于java进程也在等待notemaker进程终止，这也使得java进程也被阻塞。<br>推荐做法：<br>public class Exec<br>{<br>    public static void main(String args[]) throws IOException,<br>            InterruptedException<br>    {<br>        ProcessBuilder pb = new ProcessBuilder("notemaker");<br>        pb = pb.redirectErrorStream(true);<br>        Process proc = pb.start();<br>        InputStream is = proc.getInputStream();<br>        int c;<br>        while ((c = is.read()) != -1)<br>        {<br>            System.out.print((char) c);<br>        }<br>        int exitVal = proc.waitFor();<br>    }<br>}<br>此代码将外部程序的错误流重定向到其输出流，并通过读取Proccess对象输入流的方式将外部程序的输出缓冲区清空，防止外部程序因为外部缓冲区被填满而阻塞。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_5" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086092">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:25</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议3.2 创建文件时指定合理的访问权限<br>说明：多用户系统下的文件通常是特定用户拥有它们。文件的属主能够指定系统中的哪些其他用户能够允许访问这些文件的内容。这些文件系统使用特权权限模型来保护文件的访问。当文件被创建时，文件访问权限指定谁可以访问或操作它。当一个程序创建一个不具严格访问权限的文件时，攻击者可以在程序能够修改权限前读取或者修改这个文件。因此，必须带访问权限创建文件来防止非授权的文件访问。<br>错误示例：<br>Writer out = new FileWriter("file");<br>FileOutputStream 和 FileWriter 的构造函数不允许程序明确地指定文件的访问权限，该例创建的文件不能防止非授权访问。<br>推荐做法：使用允许程序指定初始文件权限的方法Files.newByteChannel()来创建文件<br>Path file = new File("file").toPath();<br>// Throw exception rather than overwrite existing file<br>Set&lt;OpenOption&gt; options = new HashSet&lt;OpenOption&gt;();<br>options.add(StandardOpenOption.CREATE_NEW);<br>options.add(StandardOpenOption.APPEND);<br>// File permissions should be such that only user may read/write file Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-------");<br>FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr = PosixFilePermissions.asFileAttribute(perms);<br>try (SeekableByteChannel sbc = Files.newByteChannel(file, options, attr))<br>{<br>// write data<br>};<br>Java SE 7 的新 I/O 特性（java.nio）提供了一些类来管理文件的访问权限。另外，许多方法和构造函数接受一个参数允许程序指定初始文件权限来创建文件，例如，Files.newByteChannel() 方法允许带指定权限创建一个文件。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_6" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086082">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:21</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议3.1 避免在共享目录操作文件<br>说明：多用户系统允许不同权限的用户共享一个文件系统。攻击者可以利用文件系统的一些特性（如文件链接、设备文件、共享文件访问）来对文件进行越权访问。当程序以较高的权限运行时，攻击者也有可能利用这些特性来提升自己的权限。为了防止这类漏洞，程序应只能操作安全目录下的文件。所谓的安全目录是指针对特定的用户，只有该用户或者是系统管理员才能在该目录中创建、移动和删除文件。<br>错误示例：<br>String file = /* provided by user */;<br>InputStream in = null;<br>try<br>{<br>    in = new FileInputStream(file);<br>        // ...<br>}<br>finally<br>{<br>    try<br>    {<br>        if (in != null)<br>        {<br>            in.close();<br>        }<br>     }<br>     catch (IOException x)<br>    {<br>        // handle error<br>    }<br>}<br>攻击者可以随意指定一个锁定的设备或者是一个FIFO文件，导致程序在做打开文件流操作的时候被挂起。<br>推荐做法：<br>String filename = /* provided by user */;<br>Path path = new File(filename).toPath();<br>try<br>{<br>    if (!isInSecureDir(path))<br>    {<br>        System.out.println("File not in secure directory");<br>        return;<br>    }<br>    BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);<br>    // Check<br>    if (!attr.isRegularFile())<br>    {<br>        System.out.println("Not a regular file");<br>        return;<br>    }<br>    // other necessary checks<br>    try (InputStream in = Files.newInputStream(path))<br>    {<br>        // read file<br>    }<br>}<br>catch (IOException x)<br>{<br>   // handle error<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_7" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086080">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:21</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则3.3 禁止在单个输入流InputStream上创建多份buffered wrapper<br>说明：Java中的输入流，可以对另一个输入流进行缓冲封装，以便提供更加高效的I/O,例如,Scanner和BufferedInputStream。用于外层封装的流我们称之为wrapper。如果wrapper支持预读(look-ahead)，那么在单个输入流之上创建和使用多个这样的wrapper将会使得程序的行为不可预期。这一点可以被攻击者所利用。例如，攻击者可以在控制台或者是使用System.setIn()方法对System.in进行重定向（从文件）。一般来说，支持缓冲I/O的InputStream都很容易受此形式的滥用。<br>错误示例：<br>public class InputLibrary<br>{<br>    public static char getChar() throws EOFException, IOException<br>    {<br>        // wrapper<br>        BufferedInputStream in = new BufferedInputStream(System.in);<br>        int input = in.read();<br>        if (input == -1)<br>        {<br>            throw new EOFException();<br>        }<br>        // Down casting is permitted because InputStream<br>        // guarantees read() in range<br>        // 0..255 if it is not −1<br>        return (char) input;<br>    }<br>    <br>    public static void main(String[] args)<br>    {<br>        try<br>        {<br>            // Either redirect input from the console or use<br>            // System.setIn(new FileInputStream("input.dat"));<br>            System.out.print("Enter first initial: ");<br>            char first = getChar();<br>            System.out.println("Your first initial is " + first);<br>            System.out.print("Enter last initial: ");<br>            char last = getChar();<br>            System.out.println("Your last initial is " + last);<br>        }<br>        catch (EOFException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>        catch (IOException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>    }<br>}<br>上面的代码中，每次调用getChar()方法都会对System.in封装出一个新的BufferedInputStream，且getChar()方法中的in.read()调用会对System.in进行预读以填充in中的缓冲区，导致下次再调getChar()方式时前一次预读的字节被丢失。<br>推荐做法：将BufferedInputStream对象作为类变量，以便复用。<br>public class InputLibrary<br>{<br>    private static BufferedInputStream in = new BufferedInputStream(System.in);<br>    <br>    public static char getChar() throws EOFException, IOException<br>    {<br>        int input = in.read();<br>        if (input == -1)<br>        {<br>            throw new EOFException();<br>        }<br>        in.skip(1); // This statement is to advance to the next line<br>        // The noncompliant code example deceptively<br>        // appeared to work without it (in some cases)<br>        return (char) input;<br>    }<br>    <br>    public static void main(String[] args)<br>    {<br>        try<br>        {<br>            System.out.print("Enter first initial: ");<br>            char first = getChar();<br>            System.out.println("Your first initial is " + first);<br>            System.out.print("Enter last initial: ");<br>            char last = getChar();<br>            System.out.println("Your last initial is " + last);<br>        }<br>        catch (EOFException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>        catch (IOException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_8" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086078">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:20</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则3.2 禁止将wrap()和duplicate()创建的buffer暴露给不受信任代码<br>说明：java.nio包中的一些Buffer类，例如IntBuffer、CharBuffer、以及ByteBuffer,定义了各种wrap()方法用来将基本类型的数组包装成对应的Buffer类型，对包装后得到的Buffer对象的修改也会反映到原始的数组上。同样，对使用duplicate()方法复制的出Buffer对象的修改也会反映到原始的Buffer上。将wrap()和duplicate()方法返回的Buffer暴露给不受信任的代码(非产品包中的代码)，存在原始数据可以被恶意修改的风险。为了防止此类问题发生，可以对外提供一个该Buffer的只读视图对象，或者是对外返回一份该Buffer的拷贝。<br>错误示例：<br>public class Wrap<br>{<br>    private char[] dataArray;<br>    <br>    public Wrap()<br>    {<br>        dataArray = new char[10];<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return CharBuffer.wrap(dataArray);<br>    }<br>}<br>public class Dup<br>{<br>    CharBuffer cb;<br>    <br>    public Dup()<br>    {<br>        cb = CharBuffer.allocate(10);<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return cb.duplicate();<br>    }<br>}<br>示例代码中getBufferCopy()方法的实现对外提供了对原始CharBuffer的访问。<br>推荐做法：getBufferCopy()方法返回一个原始CharBuffer的只读视图。<br>public class Wrap<br>{<br>    private char[] dataArray;<br>    <br>    public Wrap()<br>    {<br>        dataArray = new char[10];<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return CharBuffer.wrap(dataArray).asReadOnlyBuffer();<br>    }<br>}<br>public class Dup<br>{<br>    CharBuffer cb;<br>    <br>    public Dup()<br>    {<br>        cb = CharBuffer.allocate(10);<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return cb.asReadOnlyBuffer();<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_9" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086076">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:20</span>&nbsp;&nbsp;</div>
			<div class="postText2">3.	IO操作<br>规则3.1 临时文件使用完毕应及时删除<br>说明：临时文件可能包含敏感数据，为防止可能的未授权访问，需保证临时文件在使用完毕前被删除。<br>错误示例：在结束时没有删除创建的临时文件。<br>public class TempFile<br>{<br>    public static void main(String[] args) throws IOException<br>    {<br>        File f = new File("tempnam.tmp");<br>        if (f.exists())<br>        {<br>            System.out.println("This file already exists");<br>            return;<br>        }<br>        FileOutputStream fop = null;<br>        try<br>        {<br>            fop = new FileOutputStream(f);<br>            String str = "Data";<br>            fop.write(str.getBytes());<br>        }<br>        finally<br>        {<br>            if (fop != null)<br>            {<br>                try<br>                {<br>                    fop.close();<br>                }<br>                catch (IOException x)<br>                {<br>                    // handle error<br>                }<br>            }<br>        }<br>    }<br>}<br>推荐做法1：<br>public class TempFile<br>{<br>    public static void main(String[] args)<br>    {<br>        Path tempFile = null;<br>        try<br>        {<br>            tempFile = Files.createTempFile("tempnam", ".tmp");<br>            try (BufferedWriter writer = Files.newBufferedWriter(tempFile,<br>                    Charset.forName("UTF8"), StandardOpenOption.DELETE_ON_CLOSE))<br>            {<br>                // write to file<br>            }<br>            System.out.println("Temporary file write done, file erased");<br>        }<br>        catch (FileAlreadyExistsException x)<br>        {<br>            System.err.println("File exists: " + tempFile);<br>        }<br>        catch (IOException x)<br>        {<br>            // Some other sort of failure, such as permissions.<br>            System.err.println("Error creating temporary file: " + x);<br>        }<br>    }<br>}<br>该示例代码使用了 Java SE 7 的 NIO2 包中的几个方法创建了一个临时文件，使用的是 createTempFile() 方法，它创建一个不可预知的名字。使用try-with-resources结构打开文件，不管是否有异常该结构都会自动关闭文件。最后，文件是用 Java SE 7 的 DELETE_ON_CLOSE 选项打开的，这使得在文件关闭时自动删除。如果是jdk1.7之前的版本，则需在临时文件使用之后主动删除。<br>推荐做法2：<br>public class TempFile<br>{<br>    public static void main(String[] args) throws IOException<br>    {<br>        File f = File.createTempFile("tempnam", ".tmp");<br>        FileOutputStream fop = null;<br>        try<br>        {<br>            fop = new FileOutputStream(f);<br>            String str = "Data";<br>            fop.write(str.getBytes());<br>            fop.flush();<br>        }<br>        finally<br>        {<br>            if (fop != null)<br>            {<br>                try<br>                {<br>                    fop.close();<br>                    f.delete(); //delete file when finished<br>                }<br>                catch (IOException x)<br>                {<br>                    // handle error<br>                }<br>            }<br>        }<br>    }  <br>}<br>如果使用的是JDK1.7之前的版本，可以自己编写代码实现临时文件在使用完之后对其进行删除。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_10" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086075">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:20</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议2.2 禁止不受信任的代码直接终止JVM<br>说明：调用System.exit()来终止Java虚拟机（JVM）会终止所有正在运行的程序和线程。这可能会导致拒绝服务（DoS）攻击。例如，攻击者将System.exit()嵌入到JSP代码中可以使Web服务器终止，阻止继续为用户提供服务。程序必须防止无意和恶意调用System.exit（）。此外，当操作系统发出强行终止指令（例如，通过使用Windows任务管理器，POSIX kill命令，或其他机制）时，程序应该进行必要的清理。这里的非信任代码可以理解为非产品包中的代码。<br>错误示例：<br>public class InterceptExit<br>{<br>    public static void main(String[] args)<br>    {<br>        // ...<br>        System.exit(1); // Abrupt exit<br>        System.out.println("This never executes");<br>    }<br>}<br>上面代码对于使用System.exit()强制关闭JVM缺乏安全管理，它未对是否允许调用System.exit()进行检查。<br>推荐做法：<br>class PasswordSecurityManager extends SecurityManager<br>{<br>    private boolean isExitAllowedFlag;<br>    <br>    public PasswordSecurityManager()<br>    {<br>        super();<br>        isExitAllowedFlag = false;<br>    }<br>    <br>    public boolean isExitAllowed()<br>    {<br>        return isExitAllowedFlag;<br>    }<br>    <br>    @Override<br>    public void checkExit(int status)<br>    {<br>        if (!isExitAllowed())<br>        {<br>            throw new SecurityException();<br>        }<br>        super.checkExit(status);<br>    }<br>    <br>    public void setExitAllowed(boolean f)<br>    {<br>        isExitAllowedFlag = f;<br>    }<br>}<br><br>public class InterceptExit<br>{<br>    public static void main(String[] args)<br>    {<br>        PasswordSecurityManager secManager = new PasswordSecurityManager();<br>        System.setSecurityManager(secManager);<br>        try<br>        {<br>            // ...<br>            System.exit(1); // Abrupt exit call<br>        }<br>        catch (Throwable x)<br>        {<br>            if (x instanceof SecurityException)<br>            {<br>                System.out.println("Intercepted System.exit()");<br>                // Log exception<br>            }<br>            else<br>            {<br>                // Forward to exception handler<br>            }<br>        }<br>        // ...<br>        secManager.setExitAllowed(true); // Permit exit<br>        // System.exit() will work subsequently<br>        // ...<br>    }<br>}<br>安装了一个自定义的安全管理器：PasswordSecurityManager,重写checkExit()方法，增加了对一个内部标记位isExitAllowedFlag的判断，作为System.exit()操作被允许的一个必要条件，若该条件不满足，则对System.exit()的调用会抛出SecurityException（实际是checkExit()方法所抛出）。该标记位的初始值为false,只有执行了必要的清理工作后，才将该标记位设为true, setExitAllowed()用来设置该标记位。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_11" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086073">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:19</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议2.1 记录日志时避免抛异常<br>说明：如果记录日志时有异常抛出，很可能导致记录日志失败，日志记录失败有可能带来安全风险。例如：攻击者可以通过该漏洞隐瞒关键的安全异常，防止被记录。为了保证日志记录成功，程序必须保证记录日志时不会产生异常，或者即使有异常抛出，也要保证日志记录成功。<br>错误示例：<br>try<br>{<br>    // ...<br>}<br>catch (SecurityException se)<br>{<br>System.err.println(se);<br>    // Recover from exception<br>}<br>标准的错误流System.err并不适合用来记录异常日志。首先，流可能被用尽或者被关闭，另一方面，用错误流来记录一些与安全相关的异常容易泄露敏感信息。当用流来记录异常信息时发生I/O错误，则会抛出一个IOException，这会导致原始的异常信息被丢失。<br>推荐做法：记录日志时应保证不会产生异常。<br>try<br>{<br>    // ...<br>}<br>catch (SecurityException se)<br>{<br>    logger.log(Level.SEVERE, se.toString());<br>    // Recover from exception<br>}<br>使用标准的日志记录工具来记录异常信息。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_12" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086061">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:10</span>&nbsp;&nbsp;</div>
			<div class="postText2">推荐做法1：<br>public class ExceptionExample<br>{<br>    public static void main(String[] args)<br>    {<br>        File file = null;<br>        try<br>        {<br>            file = new File(System.getenv("APPDATA") + args[0]).getCanonicalFile();<br>            if (!file.getPath().startsWith("c:\\homepath"))<br>            {<br>                System.out.println("Invalid file");<br>                return;<br>            }<br>        }<br>        catch (IOException x)<br>        {<br>            System.out.println("Invalid file");<br>            return;<br>        }<br>        try<br>        {<br>            FileInputStream fis = new FileInputStream(file);<br>        }<br>        catch (FileNotFoundException x)<br>        {<br>            System.out.println("Invalid file");<br>            return;<br>        }<br>    }<br>}<br>上面代码采取了一种安全策略，只允许用户访问”c:\homepath”中的文件，而”c:\homepath”以外的文件则是对用户隐藏的。当用户试图访问”c:\homepath”以外的文件或者无效的文件路径时，程序只是给出了一个简洁的提示信息。<br>推荐做法2：<br>public class ExceptionExample<br>{<br>    public static void main(String[] args)<br>    {<br>        FileInputStream fis = null;<br>        try<br>        {<br>            switch (Integer.valueOf(args[0]))<br>            {<br>                case 1:<br>                    fis = new FileInputStream("c:\\homepath\\file1");<br>                    break;<br>                case 2:<br>                    fis = new FileInputStream("c:\\homepath\\file2");<br>                    break;<br>                //...<br>                default:<br>                    System.out.println("Invalid option");<br>                    break;<br>            }<br>        }<br>        catch (Throwable t)<br>        {<br>            MyExceptionReporter.report(t); // Sanitize<br>        }<br>    }<br>}<br>限制用户输入,只有c:\homepath\file1和c:\homepath\file2允许被用户打开，当发生异常时通过MyExceptionReporter.report()对异常中的敏感信息进行过滤清理。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_13" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086060">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:09</span>&nbsp;&nbsp;</div>
			<div class="postText2">错误示例1：异常信息和类型泄露 <br>public class ExceptionExample<br>{<br>    public static void main(String[] args) throws FileNotFoundException<br>    {<br>        // Linux stores a user's home directory path in<br>        // the environment variable $HOME, Windows in %APPDATA%<br>        FileInputStream fis = new FileInputStream(System.getenv("APPDATA")<br>                + args[0]);<br>    }  <br>}<br>当用户请求的目录不存在时，上面的代码会抛出FileNotFoundException异常，并且将目录结构信息包含在异常信息中。攻击者可以采用该方法不断伪造文件路径来重现文件系统的结构。<br>错误示例2：包装并重新抛出敏感类型异常<br>try<br>{<br>    FileInputStream fis = new FileInputStream(System.getenv("APPDATA")<br>                    + args[0]);<br>}<br>catch (FileNotFoundException e)<br>{<br>    // Log the exception<br>    throw new IOException("Unable to retrieve file", e);<br>}<br>上面代码抛出的IOException中封装了原始的异常，攻击者仍然可以通过它获取到文件系统的敏感信息。<br>错误示例3：清理异常<br>class SecurityIOException extends IOException<br>{/* ... */<br>};<br><br>// ...<br>try<br>{<br>FileInputStream fis = new FileInputStream(System.getenv("APPDATA") + args[0]);<br>}<br>catch (FileNotFoundException e)<br>{<br>// Log the exception<br>    throw new SecurityIOException();<br>}<br>虽然该示例比错误示例2泄露敏感信息的可能性要小，但是由于程序对传入的有效路径和无效路径的反应不同(前者不会抛异常，后者会抛出异常)，攻击者能够以此推测出文件系统的敏感信息。程序没有对用户的输入做限制，使得系统易受暴力攻击，攻击者可以通过输入所有可能的文件名的方式来发现有效的文件路径。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_14" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086058">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:09</span>&nbsp;&nbsp;</div>
			<div class="postText2">2.	异常行为<br>原则2.1 禁止在异常中暴露敏感信息<br>说明：这里所说的暴露敏感信息，主要是指直接向外部暴露服务器端的敏感信息。传递异常时往往会导致敏感信息泄漏（敏感信息包括但不限于：口令、密钥、证书、会话标识、License、隐私数据（如短消息的内容）、授权凭据、个人数据（如姓名、住址、电话等）等，在程序文件、配置文件、日志文件、备份文件及数据库中都有可能包含敏感信息），如果没有过滤敏感信息，可能有助于攻击者发起进一步攻击，攻击者可能会构造输入参数进一步挖掘应用程序的内部结构和实现机制。需要注意的是不只是异常中的文本描述信息会产生信息泄露，异常本身的类型信息也会导致信息泄露。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_15" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086056">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:06</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议1.1 对ZipInputStream中文件条目的大小做检查和限制<br>说明：ZIP压缩格式可以做到很高的压缩率。如果一个zip文件中的条目解压之后的大小超过了一定的上限，则应该拒绝对其进行解压，否则容易导致系统资源占用过多，形成拒绝服务攻击和zip炸弹。该规则不仅仅限定于zip格式，其它jar、rar等格式也是同样如此。此外，对普通的文件上传，文件大小也是需要控制的，否则对服务器磁盘空间资源的占用也有很大的影响。<br>错误示例：<br>static final int BUFFER = 512;<br>// ...<br>// external data source: filename<br>     BufferedOutputStream dest = null;<br>     FileInputStream fis = new FileInputStream(filename);<br>     ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));<br>     ZipEntry entry;<br>     while ((entry = zis.getNextEntry()) != null)<br>     {<br>         System.out.println("Extracting: " + entry);<br>         int count;<br>         byte data[] = new byte[BUFFER];<br>         // write the files to the disk<br>         FileOutputStream fos = new FileOutputStream(entry.getName());<br>         dest = new BufferedOutputStream(fos, BUFFER);<br>         while ((count = zis.read(data, 0, BUFFER)) != -1)<br>         {<br>            dest.write(data, 0, count);<br>         }<br>         // ...<br>     }<br>// ...<br>上面的代码未对解压出来的文件大小做判断和限制，恶意用户提供的包含巨大条目的zip文件会导致一直进行解压操作直到结束或者是资源被耗尽。<br>推荐做法：校验输入文件<br>static final int BUFFER = 512;<br>static final int TOOBIG = 0x6400000; // 100MB<br>// ...<br>// external data source: filename<br>    BufferedOutputStream dest = null;<br>    FileInputStream fis = new FileInputStream(filename);<br>    ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));<br>    ZipEntry entry;<br>    try<br>    {<br>        while ((entry = zis.getNextEntry()) != null)<br>        {<br>            System.out.println("Extracting: " + entry);<br>            // write the files to the disk, but only if file is not insanely<br>            // big<br>            if (entry.getSize() &gt; TOOBIG)<br>            {<br>                throw new IllegalStateException(<br>                        "File to be unzipped is huge.");<br>            }<br>            if (entry.getSize() == -1)<br>            {<br>                throw new IllegalStateException(<br>                        "File to be unzipped might be huge.");<br>            }<br>            int count;<br>            byte data[] = new byte[BUFFER];<br>            // write the files to the disk<br>            FileOutputStream fos = new FileOutputStream(entry.getName());<br>            dest = new BufferedOutputStream(fos, BUFFER);<br>            while ((count = zis.read(data, 0, BUFFER)) != -1)<br>            {<br>                dest.write(data, 0, count);<br>            }<br>            // ...<br>        }<br>    }<br>   // ...<br><br>上面的代码在解压zip文件中的每个条目之前，使用entry.getSize()方法获取到条目的大小，当条目的大小超过100MB或者其大小不确定时(entry.getSize() == -1)抛出异常。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_16" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086054">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:06</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则1.6 在对路径进行验证前应先对其做标准化<br>说明：路径在验证时会有很多干扰因素，如相对路径与绝对路径，路经中的“.”和“..”，路径中的符号链接、硬链接、快捷路径、别名等。另外，同一个文件可能有不同的表达方式，所以在验证路径时需要对路径进行标准化，使得路径表达唯一化后进行无歧义的比较。<br>如果没有作标准化处理，攻击者有机会：<br>构造一个跨越目录限制的文件路径，例如“../../../etc/passwd”或“../../../boot.ini”<br>构造指向系统关键文件的链接文件,例如symlink("/etc/shadow","/tmp/log")<br>通过上述两种方式之一可以实现读取或修改系统重要数据文件，威胁系统安全。<br>错误示例：<br>public static void main(String[] args)<br>    {<br>        File f = new File(System.getProperty("user.home")<br>                + System.getProperty("file.separator") + args[0]);<br>        String absPath = f.getAbsolutePath();<br>        // Validation<br>        /* … */<br>    }<br>getAbsolutePath()方法可以获取全路径，但不会将路径中的“..”处理掉。<br>推荐做法：<br>public static void main(String[] args) throws IOException<br>    {<br>        File f = new File(System.getProperty("user.home")<br>                + System.getProperty("file.separator") + args[0]);<br>        String canonicalPath = f.getCanonicalPath();<br>        // Validation<br>        /* ... */<br>    }<br>在验证路径之前应该用getCanonicalPath()对路径进行标准化，使得路径表达式唯一，无歧义。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_17" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086053">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:06</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则1.5 禁止直接将外部输入传递给Runtime.exec()方法<br>说明：如果输入的数据不经审查就作为参数直接传递给Runtime.exec()方法，则容易形成命令行注入与参数注入攻击漏洞。命令行注入攻击只有在Runtime.exec()中调用了命令行解释器（如Windows中的cmd.exe和POSIX中的sh）的情况下才有可能发生，因为只有命令行解释器才能通过命令分隔符来执行多条命令。另外需要注意的是，当使用Runtime.exec()执行bat或者sh脚本时，会自动调用命令行解释器来执行。例如，当执行下面的语句:<br>Runtime.getRuntime().exec(“test.bat &amp; notepad.exe”);<br>由于对于bat脚本会默认使用cmd.exe来执行，后面的“&amp;”会被当做命令分隔符处理，test.bat和notepad.exe都会被执行。而对于参数注入攻击，当参数中包含空格、双引号、以“-”或者“/”开头来指定开关参数时都有可能发生。<br>错误示例：<br>class DirList<br>{<br>    public static void main(String[] args) throws Exception<br>    {<br>        String dir = System.getProperty("dir");<br>        Runtime rt = Runtime.getRuntime();<br>        Process proc = rt.exec("cmd.exe /C dir " + dir);<br>        // …<br>    }<br>}<br>对于上述代码，攻击者可以通过以下方式执行程序:<br>java –Ddir='dummy &amp; echo bad' DirList<br>则实际执行了两个命令:<br>dir dummy <br>echo bad<br>前一条命令尝试罗列目录的内容，后一条命令打印信息到控制台。<br>推荐做法1(避免Runtime.exec())：<br>class DirList<br>{<br>    public static void main(String[] args) throws Exception<br>    {<br>        File dir = new File(System.getProperty("dir"));<br>        if (!dir.isDirectory())<br>        {<br>            System.out.println("Not a directory");<br>        }<br>        else<br>        {<br>            for (String file : dir.list())<br>            {<br>                System.out.println(file);<br>            }<br>        }<br>      }<br>}<br>在有其他选择的情况下，请尽量避免使用Runtime.exec()执行命令行调用来完成一项任务。<br>推荐做法2(输入校验)：<br>// . ..<br>if (!Pattern.matches("[0-9A-Za-z@.]+", dir))<br>{<br>    // Handle error<br>}<br>// ...<br>当无法避免使用Runtime.exec()时，需对用户输入做校验或限制，防止其中包含一些命令分隔符或者重定向符（“&amp;&amp;”、“&amp;”、“||”、“|”），用于连续执行多个命令或者重定向输入输出。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_18" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086049">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:02</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则1.4 禁止直接使用用户输入的数据来构造格式化字符串<br>说明：Java解释格式化字符串比较严格，当匹配对应的格式化字符，转换参数失败时，标准库会抛出异常，这种方式可以减少被恶意攻击的机会。但是恶意用户仍然可以通过格式化字符串注入引起信息泄露或者拒绝服务攻击。 因此，不能直接将来自不可信源的字符串用于构造格式化字符串。<br>错误示例：<br>class Format<br>{<br>    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);<br>    <br>    public static void main(String[] args)<br>    {<br>        // args[0] is the credit card expiration date<br>        // args[0] can contain either %1$tm, %1$te or %1$tY as malicious arguments<br>        // First argument prints 05 (May), second prints 23 (day)<br>        // and third prints 1995 (year)<br>        // Perform comparison with c, if it doesn't match print the following line<br>        System.out.printf(args[0]<br>                + " did not match! HINT: It was issued on %1$terd of some month",<br>                c);<br>    }<br>}<br>上面代码中，如果arg[0]包含恶意格式化字符串%1$tm,%1$te或者%1$tY，则会导致用来做比较验证的日期信息被暴露。<br>推荐做法：将用户的输入排除在格式化字符串之外<br>class Format<br>{<br>    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);<br>    <br>    public static void main(String[] args)<br>    {<br>        // args[0] is the credit card expiration date<br>        // Perform comparison with c,<br>        // if it doesn't match print the following line<br>        System.out.printf("%s did not match! "<br>                + " HINT: It was issued on %1$terd of some month", args[0], c);<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_19" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086048">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:02</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则1.3 对字符串校验之前先要对其做归一化<br>说明：对外部输入字符串校验之前，需要使用java.text.Normalizer的normalize()方法先对其进行归一化（Unicode Normalization）处理。归一化可以确保具有相同意义的字符串具有统一的二进制描述。推荐使用的归一化格式是NFKC，因为它将输入转换成可与目标进行安全比较的等效标准格式。<br>错误示例：<br>// String s may be user controllable<br>String s = "\uFE64" + "script" + "\uFE65";<br>// Validate<br>Pattern pattern = Pattern.compile("[&lt;&gt;]"); // Check for angle brackets<br>Matcher matcher = pattern.matcher(s);<br>if (matcher.find())<br>{<br>    // Found black listed tag<br>    throw new IllegalStateException();<br>}<br>// . . .<br>如上示例代码的本意是防止外部输入中包含正反尖括号: &lt; (\u003C)和 &gt; (\u003E)。但是在Unicode中正反尖括号还有另外一种非标准的表达方式：&lt; (\uFE64)和 &gt; (\uFE65)。攻击者可以利用这种非标准的表达方式来绕过输入检查。<br>推荐做法：<br>String s = "\uFE64" + "script" + "\uFE65";<br>// Normalize<br>// \uFE64 is normalized to &lt; and \uFE65 is normalized to &gt; using NFKC<br>s = Normalizer.normalize(s, Form.NFKC);<br>// Validate<br>Pattern pattern = Pattern.compile("[&lt;&gt;]");<br>Matcher matcher = pattern.matcher(s);<br>if (matcher.find())<br>{<br>    // Found black listed tag<br>    throw new IllegalStateException();<br>}<br>// . . .<br>在进行校验之前先对输入的字符串做归一化处理，可以将使用非标准表达方式的字符串转换成统一的标准表达形式，从而使其不能绕过输入校验。</div>				
		</div>
	<div class="line"></div>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;7&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">下一页</a>&nbsp;
</div></div>
</div>


			</td>
		</tr>
		</tbody></table>
	</td>
	<td width="10">&nbsp;</td>
	<td valign="top">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
			<table width="100%" height="200">
			<tbody><tr>
				<td><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/09/01&#39;);return false;">&lt;</a></td><td align="center">2018年10月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/11/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td class="CalWeekendDay" align="center">6</td></tr><tr><td class="CalWeekendDay" align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td class="CalWeekendDay" align="center">13</td></tr><tr><td class="CalWeekendDay" align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalWeekendDay" align="center">20</td></tr><tr><td class="CalWeekendDay" align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">24</td><td align="center">25</td><td align="center">26</td><td class="CalWeekendDay" align="center">27</td></tr><tr><td class="CalWeekendDay" align="center">28</td><td align="center">29</td><td align="center">30</td><td align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></td>
			</tr>
			</tbody></table>
				
<h1>&nbsp;公告</h1><br>
<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/chenyankai/">hunyihun</a><br>园龄：<a href="https://home.cnblogs.com/u/chenyankai/" title="入园时间：2013-11-13">4年10个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/chenyankai/followers/">0</a><br>关注：<a href="https://home.cnblogs.com/u/chenyankai/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;bb2fa9a6-374c-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('bb2fa9a6-374c-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
	
				
<h1>&nbsp;导航</h1>
<ul class="list" type="square">
	<li class="listitem"><a id="blog_nav_sitehome" class="listitem" href="https://www.cnblogs.com/">博客园</a></li>
	<li class="listitem"><a id="blog_nav_myhome" class="listitem" href="https://www.cnblogs.com/chenyankai/">首页</a></li>
	<li class="listitem"><a id="blog_nav_newpost" class="listitem" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">发新随笔</a></li>
	<li class="listitem"><a id="MyLinks1_NewArticleLink" class="listitem" href="https://www.cnblogs.com/EnterMyBlog.aspx?NewArticle=1">发新文章</a></li>
	<li class="listitem"><a id="blog_nav_contact" accesskey="9" class="listitem" rel="nofollow" href="https://msg.cnblogs.com/send/hunyihun">联系</a></li>
	<li class="listitem"><a id="blog_nav_rss" class="listitem" href="https://www.cnblogs.com/chenyankai/rss">订阅</a><a id="blog_nav_rss_image" href="https://www.cnblogs.com/chenyankai/rss"><img src="./最新评论 - hunyihun - 博客园7_files/xml.gif" alt="订阅"></a>
	</li><li class="listitem"><a id="blog_nav_admin" class="listitem" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

				<div id="blog_stats">
<h1>&nbsp;统计</h1>
	<ul class="list" type="square">
		<li class="listitem">随笔： 2
		</li><li class="listitem">文章： 0
		</li><li class="listitem">评论： 155
		</li><li class="listitem">引用： 0
	</li>
</ul></div>
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/chenyankai/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="https://www.cnblogs.com/chenyankai/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="https://www.cnblogs.com/chenyankai/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">

</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
		<h1 class="listtitle">随笔档案</h1>
		
				<ul class="list" type="square">
			
				<li class="listitem"><a id="CatList_LinkList_0_Link_0" class="listitem" href="https://www.cnblogs.com/chenyankai/archive/2014/09.html">2014年9月 (2)</a> </li>
			
				</ul>
			
	
</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<h3 class="catListTitle">最新评论</h3>
<div class="RecentComment" id="RecentComments">
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097337">1. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">使用强随机数说明：安全敏感的代码块（如SessionID的生成、挑战算法中的随机数生成等），必须采用强随机数，禁止使用伪随机数。Java API 提供了伪随机数生成器（PRNG）——java.util......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097329">2. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">原则7.3 基于哈希算法的口令安全存储必须加入盐值（salt）说明：单向哈希是在一个方向上工作的哈希函数，从预映射的值很容易计算其哈希值，但要根据特定哈希值产生一个预映射的值却是非常困难的。单向哈希主......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097327">3. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">7.	其它原则7.1 禁止在日志中保存口令、密钥说明： 在日志中不能保存口令和密钥，其中的口令包括明文口令和密文口令。对于敏感信息建议采取以下方法，1）不打印在日志中；2）若因为特殊原因必须要打印日志......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097326">4. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">避免依赖和信任环境变量说明：使用环境变量会带来可以移植性问题，在不同的操作系统中其语义可能有所不同。因此要尽量避免使用环境变量。对于一个值如果有定义的系统属性(System properties)可用......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097325">5. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">所有安全相关的敏感代码都放在一个jar包中，并签名再加密说明：若安全相关的敏感代码（例如进行权限控制或者用户名密码校验的代码）没有放到同一个受信任的jar包中，攻击者可以通过先加载恶意代码（使用相同的......</li>
        <li class="recent_comment_author">--hunyihun</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<h3 class="catListTitle">阅读排行榜</h3>
<div class="RecentComment" id="TopViewPosts"> 
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(67)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(15)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<h3 class="catListTitle">评论排行榜</h3>
<div class="RecentComment" id="TopCommentsPosts">
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(97)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(58)</a></li></ul></div>
</div></div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap" style="display: none;">
<h3 class="catListTitle">推荐排行榜</h3>
<div class="RecentComment">
	<div id="TopDiggPostsBlock"></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			<br>
			
<div class="footer">
	Powered by: <a href="http://www.cnblogs.com/">博客园</a><br>模板提供：<a href="http://blog.hjenglish.com/">沪江博客</a><br>
	Copyright ©2018 hunyihun
</div>
			</td>
		</tr>
		</tbody></table>
	</td>
</tr>
</tbody></table>
<br>



</body></html>