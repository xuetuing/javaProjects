<!DOCTYPE html>
<!-- saved from url=(0061)https://www.cnblogs.com/chenyankai/recentcomments.html?page=6 -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<title>最新评论 - hunyihun - 博客园</title>
<link type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园6_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园6_files/bundle-classic.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园6_files/bundle-classic-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/chenyankai/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/chenyankai/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/chenyankai/wlwmanifest.xml">
<script async="" src="./最新评论 - hunyihun - 博客园6_files/analytics.js.下载"></script><script src="./最新评论 - hunyihun - 博客园6_files/jquery-2.2.0.min.js.下载"></script>
<script type="text/javascript">var currentBlogApp = 'chenyankai', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./最新评论 - hunyihun - 博客园6_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<table align="center" width="98%" cellspacing="0" cellpadding="0" border="0" style="margin-top:10px">
<tbody><tr>
	<td valign="top" width="70%" style="padding:0">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
<div id="header">
	<span>
		<a id="Header1_HeaderTitle" href="https://www.cnblogs.com/chenyankai/">hunyihun</a><br>
		<div class="sub"></div>
	</span>
</div>
			</td>
		</tr>
		</tbody></table>
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white" class="index">
		<tbody><tr>
			<td class="main">
			

<div id="myposts">
<h3 class="myposts_title">最新评论</h3>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;6&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">下一页</a>&nbsp;
</div></div>

		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_0" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086295">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:43</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议1	数组声明的时候使用 int[] index，而不要使用 int index[]<br>说明： int[] index表示声明了一个int数组叫做index，符合人的阅读习惯，可读性较好。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_1" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086294">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:43</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则6	包的命名，由一个或若干个单词组成，所有的字母均为小写<br>说明：包名采用域后缀倒置的加上自定义的包名，采用小写字母，都应该以com.huawei开头（除一些特殊原因），再加上产品名称和模块名称。部门内部应该规划好包名的范围，防止产生冲突。<br>示例：com.huawei.mobilecontrol.views;</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_2" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086291">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:42</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则5	类和接口的命名，采用首字母大写的驼峰命名法<br>说明：类的命名，不应用动词，而应使用名词，比如Customer，WikiPage，Account，避免采用类似Manager，Processor，Data，Info这样模糊的词。接口命名不要以I开头，I开头提供了过多的信息，分散了注意力。比如，一个创建形状的工厂ShapeFactory，并不需要命名为IShapeFactory，因为很多时候接口的用户并不真正需要知道传递给他的是一个Interface类型，只需知道是ShapeFactory即可，至于是用Interface实现的还是Abstract Class实现的，并不需要关心。<br>示例：<br>不好：<br>public class info {}	<br>public interface IFly{}<br>public class FlyImpl implements IFly {}<br>推荐：<br>public class OrderInformation {}<br>public interface Flyable{}<br>public class Bird implements Flyable {}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_3" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086288">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:41</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则2	常量命名，由全大写单词组成，单词间用下划线分隔，且使用 static final修饰<br>示例：<br>不好：<br>static int MAXUSERNUM = 200;<br>static String s = "Launcher";<br>推荐：<br>static final int MAX_USER_NUM = 200;<br>static final String APPLICATION_NAME = "Launcher";<br>规则3	变量、属性命名，使用名词，并采用首字母小写的驼峰命名法<br>说明：驼峰命名是指第一个单词字母使用小写，剩余单词首字母大写其余字母小写的大小写混合法。含有集合意义的属性，名称尽量包含复数；<br>示例：<br>不好：<br>String customername;<br>List&lt;String&gt; u = new ArrayList&lt;String&gt;();<br>推荐：<br>String customerName;<br>List&lt;String&gt; users = new ArrayList&lt;String&gt;();<br>规则4	方法的命名，用动词和动宾结构，并采用首字母小写的驼峰命名法<br>说明：格式如下 <br>get + 非布尔属性名()<br>is + 布尔属性名()<br>set + 属性名()<br>has + 名词/形容词()<br>动词()<br>动词 + 宾语()<br>示例：<br>不好：<br>public String type()<br>public boolean Finished()<br>public void visible(boolean)<br>public void DRAW()<br>public void KeyListener(Listener)<br>推荐：<br>public String getType()<br>public boolean isFinished()<br>public void setVisible(boolean)<br>public void draw()<br>public void addKeyListener(Listener)</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_4" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086285">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:37</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则1	禁止使用魔鬼数字<br>说明：直接使用数字，造成代码难以理解，也难以维护。应采用有意义的静态变量或枚举来代替。它的好处除了能使代码容易理解外，还消除了重复，在需要修改时，只需修改一处即可。<br>示例：<br>不好： <br>int doorState  = 1;<br><br>推荐：<br>static final int CLOSE = 1;<br>int doorState = CLOSE;<br>enum  Signal {  <br>    GREEN, YELLOW, RED  <br>}  <br>public class TrafficLight {  <br>    Signal color = Signal.RED;  <br>    public void change() {  <br>        switch (color) {  <br>        case RED:  <br>            color = Signal.GREEN;  <br>            break ;  <br>        case YELLOW:  <br>            color = Signal.RED;  <br>            break ;  <br>        case GREEN:  <br>            color = Signal.YELLOW;  <br>            break ;  <br>        default:<br>	      color = Signal.RED;<br>        }  <br>    }  <br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_5" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086261">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:15</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则7.2 与非信任代码交互的类的方法或代码块同步要使用私有不变对象锁<br>说明：有两种方法来同步访问共享可变变量：同步方法和同步块。声明为同步的方法以及在this引用上的同步块都使用对象自身的锁（隐式锁）。攻击者可以通过获取一个可访问类对象的隐式锁并无限期持有来该锁来触发条件竞争与死锁，进而引起拒绝服务（DoS）。当一个类会暴露出去与非信任代码交互时，对这个类中的代码做同步应该使用私有不变对象锁(private lock object idiom)，使得攻击者无法获取到锁对象。<br>错误示例：<br>public class SomeObject<br>{<br>    // Locks on the object's monitor<br>    public synchronized void changeValue()<br>    {<br>        // . . .<br>    } <br>}<br>// Untrusted code<br>SomeObject theObject = getTheObject ();<br>synchronized (someObject)<br>{<br>while (true)<br>    {<br>        // Indefinitely delay someObject<br>        Thread.sleep(Integer.MAX_VALUE);<br>    }<br>}<br>不可信代码尝试获取theObject的隐式锁，一旦成功便无限期的占用，导致其他代码调用changeValue()方法时因无法获取到锁而被无限阻塞。<br>推荐做法：使用私有不变对象锁，使得攻击无法获取到锁对象。<br>public class SomeObject<br>{<br>    private final Object lock = new Object(); // private final lock object<br>    <br>    public void changeValue()<br>    {<br>        synchronized (lock)<br>        { // Locks on the private Object<br>            // . . .<br>        }<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_6" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086259">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:14</span>&nbsp;&nbsp;</div>
			<div class="postText2">原则7.5 删除或修改没有效果的代码<br>说明：删除或修改一些即使执行后、也不会有任何效果的代码。一些存在的代码（声明或表达式），即使它被执行后，也不会对代码结果或数据状态产生任何影响，或者产生不是所预期的效果，这样的代码可能是由于编码错误引起的，往往隐藏着逻辑上的错误，需要对其进行删除或修改。<br>原则7.6 删除或修改没有使用到的变量或值<br>说明：删除或修改没有使用到的变量或值。一些变量或值存在于代码中，但并没有被使用到，这可能隐含着逻辑上的错误，需要被识别出来，删除这类语句或做相应的修改。<br>规则7.1 使用强随机数<br>说明：安全敏感的代码块（如SessionID的生成、挑战算法中的随机数生成等），必须采用强随机数，禁止使用伪随机数。Java API 提供了伪随机数生成器（PRNG）——java.util.Random类。伪随机数具有可重复性：在任意Java实现中使用同样的seed会产生同样的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。很多情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测出伪随机数生成器将要使用的seed值，从而获得由java.util.Random类生成的随机数。<br>因此，java.util.Random 类不应用于安全应用或者敏感数据保护，应使用更加安全的随机数生成器java.security.SecureRandom。<br>引申说明：伪随机数生成器利用的是数学中确定性算法产生的具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器最开始利用一个seed值产生一个伪随机数和一个新的seed值，然后再利用生成的seed值产生下一个伪随机数。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_7" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086258">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:14</span>&nbsp;&nbsp;</div>
			<div class="postText2">原则7.3 基于哈希算法的口令安全存储必须加入盐值（salt）<br>说明：单向哈希是在一个方向上工作的哈希函数，从预映射的值很容易计算其哈希值，但要根据特定哈希值产生一个预映射的值却是非常困难的。单向哈希主要应用于加密、消息完整性校验、冗余校验等。假如没有加入盐值，则加密原理是：<br>密文= 哈希算法（明文）<br>此时，若攻击者获取到密文，同时知道哈希算法，则就可以通过字典攻击来探测和获取口令。加入盐值之后：<br>密文= 哈希算法（明文+盐值）<br>其中盐值可以随机设置，这样即使相同的口令但盐值不同密文也不同，从而增加了口令的破解难度、增强安全性。<br>原则7.4 禁止将连接字符串硬编码在程序中，若其中包含敏感信息，则敏感信息必须进行加密保存<br>说明：在连接数据库等操作时，不能将连接字符串硬编码在程序中；若连接字符串中包含有口令、初始密钥等敏感信息，这些敏感信息还必须加密保存，若直接硬编码或不加密保存，敏感信息可以很容易被攻击者通过反编译/汇编获取到。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_8" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086256">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:12</span>&nbsp;&nbsp;</div>
			<div class="postText2">7.	其它<br>原则7.1 禁止在日志中保存口令、密钥<br>说明： 在日志中不能保存口令和密钥，其中的口令包括明文口令和密文口令。对于敏感信息建议采取以下方法，<br>1）不打印在日志中；<br>2）若因为特殊原因必须要打印日志，则用“*”代替。<br>原则7.2 使用经过验证的安全的标准加密算法，禁用私有算法或者弱加密算法<br>说明：禁用私有算法或者弱加密算法（如DES，SHA1等），应该使用经过验证的、安全的、公开的加密算法。<br>加密算法分为对称加密算法和非对称加密算法。推荐使用的常用对称加密算法有:<br>	AES<br>推荐使用的常用非对称算法有:<br>	RSA<br>	数字签名算法（DSA）<br>此外还有验证消息完整性的安全哈希算法（SHA256）等。基于哈希算法的口令安全存储必须加入盐值（salt）。<br>密钥长度符合最低安全要求：<br>	AES：  128位<br>	RSA：  2048位<br>	DSA：  1024位<br>	SHA：  256位</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_9" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086255">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 14:12</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议6.2 避免依赖和信任环境变量<br>说明：使用环境变量会带来可以移植性问题，在不同的操作系统中其语义可能有所不同。因此要尽量避免使用环境变量。对于一个值如果有定义的系统属性(System properties)可用，应该优先考虑使用系统属性，比如对于操作系统的用户名，可以通过user.name系统属性获得。除了可移植性问题，使用环境变量还会有安全性问题，攻击者可以通过某种机制(比如使用java.lang.ProcessBuilder)从根本上控制进入到某个程序中的所有环境变量的值。因此，如果确实需要用到环境变量，也需要在使用之前对其进行校验。<br>错误示例：<br>String username = System.getenv("USER");<br>首先，这段代码会遇到可移植性问题，在Unix中可以通过"USER"访问用户名，但是在windows系统中则是通过环境变量"USERNAME"来获取。另一方面，攻击者可以在执行程序的时候为"USER"指定任意的值。<br>推荐做法：使用JVM系统属性替代操作系统环境变量<br>String username = System.getProperty("user.name");</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_10" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086173">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 12:31</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议6.1 所有安全相关的敏感代码都放在一个jar包中，并签名再加密<br>说明：若安全相关的敏感代码（例如进行权限控制或者用户名密码校验的代码）没有放到同一个受信任的jar包中，攻击者可以通过先加载恶意代码（使用相同的类名）的方式，使受信任的敏感代码执行攻击者"植入"的代码，从而达到控制受信任代码执行逻辑的目录。<br>错误示例：<br>package trusted;<br><br>import untrusted.RetValue;<br><br>public class MixMatch<br>{<br>    private void privilegedMethod() throws IOException<br>    {<br>        try<br>        {<br>            final FileInputStream fis = <br>                    AccessController.doPrivileged(new PrivilegedExceptionAction&lt;FileInputStream&gt;()<br>            {<br>                public FileInputStream run() throws FileNotFoundException<br>                {<br>                    return new FileInputStream("file.txt");<br>                }<br>            });<br>            try<br>            {<br>                RetValue rt = new RetValue();<br>                if (rt.getValue() == 1)<br>                {<br>                    // do something with sensitive file<br>                }<br>            }<br>            finally<br>            {<br>                fis.close();<br>            }<br>        }<br>        catch (PrivilegedActionException e)<br>        {<br>            // forward to handler and log<br>        }<br>    }<br>    <br>    public static void main(String[] args) throws IOException<br>    {<br>        MixMatch mm = new MixMatch();<br>        mm.privilegedMethod();<br>    }<br>}<br>// In another JAR file:<br>package untrusted;<br><br>class RetValue<br>{<br>    public int getValue()<br>    {<br>        return 1;<br>    }<br>}<br>攻击者可以通过提供同样的类RetValue,在其getValue() 方法中返回自己需要结果，从而达到攻击的目的。<br>推荐做法：<br>package trusted;<br><br>public class MixMatch<br>{<br>    // ...<br>}<br>// In the same signed &amp; sealed JAR file:<br>package untrusted;<br><br>class RetValue<br>{<br>    public int getValue()<br>    {<br>        return 1;<br>    }<br>}<br>将所有的类放在一个包中，同时在jar包的manifest文件中设置Sealed属性:<br>Sealed: true // sealed属性</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_11" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086172">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 12:31</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则6.1 不要禁用JVM的字节码验证<br>说明：JVM中包含一个字节码验证器组件，用来检查提交到JVM中的字节码文件(.class文件)是否合规，包括确保class文件的格式正确性、没有出现非法的类型转换、不会出现方法调用堆栈溢出等等。因此字节码验证可以防止经攻击者非法篡改过的字节码文件被提交到JVM中去执行。<br>错误示例：<br>java -Xverify:none ApplicationName<br>字节码验证默认会被JVM所执行，而JVM命令行参数-Xverify:none会让JVM跳过字节码验证。<br>推荐做法：<br>java -Xverify:all ApplicationName<br>使用-Xverify:all参数强制JVM进行字节码验证。<br>规则6.2 禁止开启JVM可被远程监控的参数项<br>说明：Java提供了多种API让外部程序来监控运行中的Java程序，这些外部程序可以运行在本地，也可以远程运行在不同的主机上。如果允许运行在生产环境中的Java程序被远程监控，那么攻击者便可以连接到JVM，监控其行为和数据，包括潜在的敏感信息。因此，当一个应用程序部署在生产环境的时候，禁止在JVM的运行参数中加入开启监控的选项。<br>错误示例1：JVMTI<br>${JDK_PATH}/bin/java -agentlib:libname=options ApplicationName<br>JVM Tool Interface(JVMTI)通过代理来与运行中的JVM通信。上例中，通过Java命令行参数-agentlib让JVM启动的时候加载JVMTI代理，从而允许JVMTI对应用程序进行监控。<br>错误示例2：JVM monitoring<br>${JDK_PATH}/bin/java -Dcom.sun.management.jmxremote.port=8000 ApplicationName<br>上例中的命令行参数使得JVM被允许在8000端口上进行远程监控。<br>推荐做法：<br>${JDK_PATH}/bin/java -Djava.security.manager ApplicationName<br>上面的命令行摈弃了开启远程监控的相关参数，并且安装了默认的安全管理器。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_12" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086166">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 12:27</span>&nbsp;&nbsp;</div>
			<div class="postText2">6.	运行安全<br>原则6.1 禁止给仅执行非特权操作的代码签名 <br>说明：在Java中代码签名可以让代码获得更高的权限,许多安全策略允许被签名的代码执行更高权限的操作。代码签名被设计为用来对代码的来源做认证以及验证代码的完整性，它依赖于一个认证机构来确认签名者的身份。用户普遍的将数字签名与代码的安全执行相关联，相信签名的代码不会带来危害，若签名的代码出现漏洞则会产生问题,因为许多系统被配置为固定的信任某些签名机构，如果系统下载了由这些机构签名的包含漏洞的代码，则系统将不会警告和通知用户。攻击者可以向用户输送带有合法签名的漏洞代码，并利用这些漏洞。由于上述问题，对于那些不需要执行特权操作的代码不要对其进行签名，让它们运行在受限的沙箱里面。<br>原则6.2 不要使用危险的权限组合<br>说明：有些权限的组合会导致权限过大，而这些权限本不应该被赋予。<br>1、不要将AllPermission权限赋予给不信任的代码<br>2、不要使用ReflectPermission和suppressAccess的权限组合<br>3、不要使用ChecksRuntimePermission和createClassLoader的权限组合<br>错误示例：赋予代码AllPermission权限<br>// Grant the klib library AllPermission<br>grant codebase "file:${klib.home}/j2se/home/klib.jar" {<br>    permission java.security.AllPermission;<br>};<br>推荐做法： 进行细粒度授权<br>grant codeBase<br>"file:${klib.home}/j2se/home/klib.jar", signedBy "Admin" {<br>    permission java.io.FilePermission "/tmp/*", "read";<br>    permission java.io.SocketPermission "*", "connect";</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_13" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086165">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 12:26</span>&nbsp;&nbsp;</div>
			<div class="postText2">建议5.1 避免完全依赖URLClassLoader和java.util.jar默认提供的自动签名认证机制<br>说明：不要完全依赖URLClassLoader和java.util.jar默认提供的自动签名认证机制，必要时程序调用者需要主动获取证书信息并进行校验。<br>默认情况下，自动签名认证机制使用在JAR文件中包含的公钥来验证签名，这个机制无法保证公钥和签名的未被恶意篡改。使用默认的自动签名验证过程必须执行额外的检查，以确保该签名的正确性（如与一个已知的受信任签名进行比较）。<br>错误示例：<br>public class JarRunner<br>{<br>    public static void main(String[] args) throws IOException,<br>            ClassNotFoundException, NoSuchMethodException,<br>            InvocationTargetException<br>    {<br>        <br>        URL url = new URL(args[0]);<br>        <br>        // Create the class loader for the application jar file<br>        JarClassLoader cl = new JarClassLoader(url);<br>        <br>        // Get the application's main class name<br>        String name = cl.getMainClassName();<br>        <br>        // Get arguments for the application<br>        String[] newArgs = new String[args.length - 1];<br>        System.arraycopy(args, 1, newArgs, 0, newArgs.length);<br>        <br>        // Invoke application's main class<br>        cl.invokeClass(name, newArgs);<br>    }<br>}<br><br>final class JarClassLoader extends URLClassLoader<br>{<br>    private URL url;<br>    <br>    public JarClassLoader(URL url)<br>    {<br>        super(new URL[] {url});<br>        this.url = url;<br>    }<br>    <br>    public String getMainClassName() throws IOException<br>    {<br>        URL u = new URL("jar", "", url + "!/");<br>        JarURLConnection uc = (JarURLConnection) u.openConnection();<br>        Attributes attr = uc.getMainAttributes();<br>        return attr != null ? attr.getValue(Attributes.Name.MAIN_CLASS) : null;<br>    }<br>    <br>    public void invokeClass(String name, String[] args)<br>            throws ClassNotFoundException, NoSuchMethodException,<br>            InvocationTargetException<br>    {<br>        Class c = loadClass(name);<br>        Method m = c.getMethod("main", new Class[] {args.getClass()});<br>        m.setAccessible(true);<br>        int mods = m.getModifiers();<br>        if (m.getReturnType() != void.class || !Modifier.isStatic(mods)<br>                || !Modifier.isPublic(mods))<br>        {<br>            throw new NoSuchMethodException("main");<br>        }<br>        try<br>        {<br>            m.invoke(null, new Object[] {args});<br>        }<br>        catch (IllegalAccessException e)<br>        {<br>            System.out.println("Access denied");<br>        }<br>    }<br>}<br>示例代码为JarRunner演示程序，可以动态执行JAR文件中一个特定类。该程序创建JarClassLoader，通过不信任的网络如Internet来加载程序更新、插件或补丁。第一个参数是获取代码的URL，其他参数指定传递给加载类的参数。JarRunner使用反射来调用被加载类的main()方法。不幸的是，默认情况下，JarClassLoader使用JAR文件中包含的公钥来验证签名。<br>推荐做法：<br>public void invokeClass(String name, String[] args)<br>        throws ClassNotFoundException, NoSuchMethodException,<br>        InvocationTargetException, GeneralSecurityException, IOException<br>{<br>    Class c = loadClass(name);<br>    Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();<br>    if (certs == null)<br>    {<br>        // return, do not execute if unsigned<br>        System.out.println("No signature!");<br>        return;<br>    }<br> <br>    KeyStore ks = KeyStore.getInstance("JKS");<br>    ks.load(new FileInputStream(System.getProperty("user.home"<br>            + File.separator + "keystore.jks")),<br>            "loadkeystorepassword".toCharArray());<br>    // user is the alias<br>    Certificate pubCert = ks.getCertificate("user");<br>    // check with the trusted public key, else throws exception<br>    certs[0].verify(pubCert.getPublicKey());<br>}<br>当本地系统不能可靠验证签名时，则调用程序必须在代码里面从加载类的CodeSource中获取证书链，然后检查证书是否属于受信任的签名者，受信任签名者的证书已事先获取并保存在本地密钥库中。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_14" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086116">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:34</span>&nbsp;&nbsp;</div>
			<div class="postText2">规则5.1 防止特权块向非信任域泄漏敏感信息<br>说明：当与非信任代码（非产品包中的代码）交互时，对敏感数据访问的接口需要控制访问权限。<br>Java.security.AccessController负责访问控制算法的实现，在执行安全检查的时候，AccessCont<br>-roller默认将对方法调用栈上的所有类的权限做检查。但是为了能够让原本不具有某操作权限的类能够临时通过具有该权限的类间接进行访问，Java提供了特权代码块机制。AccessController的静态方法doPrivileged()接收一个PrivilegedAction类型的对象参数，并将以“特权”的方式执行PrivilegedAction中所定义的Run()方法，这里的“特权”是指AccessController在对方法调用栈上的类从上至下做权限检查的时只会检查到调用了AccessController .doPrivileged()方法的类，而忽略其后的类。 由于包含特权代码块方法的调用者(不受信任代码)不受安全检查的限制，因此包含特权代码的方法和类应该保证敏感操作的安全性，防止敏感操作被不受信任代码恶意调用以及敏感资源信息外泄。 <br>假设一个Web应用程序为Web服务维护一个敏感的口令文件，同时也运行不受信任的代码。那么，Web应用程序可以实施一种安全策略，来防止自身的大部分代码和不受信任代码访问敏感文件。由于必须要提供添加和修改口令的机制，可通过调用doPrivileged()方法来临时允许不受信任代码访问敏感文件。这种情况下，任何特权块必须防止不受信任代码访问口令信息。<br>错误示例：<br>public class PasswordManager<br>{   <br>    public static void changePassword() throws FileNotFoundException<br>    {<br>        FileInputStream fin = openPasswordFile();<br>        <br>        // test old password with password in file contents; change password<br>        // then close the password file<br>    }<br>    <br>    public static FileInputStream openPasswordFile()<br>            throws FileNotFoundException<br>    {<br>        final String password_file = "password";<br>        FileInputStream fin = null;<br>        try<br>        {<br>            fin = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;FileInputStream&gt;()<br>            {<br>                public FileInputStream run() throws FileNotFoundException<br>                {<br>                    // Sensitive action; can't be done outside privileged block<br>                    FileInputStream in = new FileInputStream(password_file);<br>                    return in;<br>                }<br>            });<br>        }<br>        catch (PrivilegedActionException x)<br>        {<br>            Exception cause = x.getException();<br>            if (cause instanceof FileNotFoundException)<br>            {<br>                throw (FileNotFoundException) cause;<br>            }<br>            else<br>            {<br>                throw new Error("Unexpected exception type", cause);<br>            }<br>        }<br>        return fin;<br>    }<br>}<br>doPrivileged（）被openPasswordFile()方法所调用，openPasswordFile()方法通过“特权”代码获取并返回口令文件的输入流。由于openPasswordFile()方法为public，它可能被不受信任代码所调用，从而引起敏感信息泄漏。<br>推荐做法：将openPasswordFile()方法声明为私有。<br>public class PasswordManager<br>{   <br>    public static void changePassword() throws FileNotFoundException<br>    {<br>        // ...<br>    }<br>    <br>    private static FileInputStream openPasswordFile()<br>            throws FileNotFoundException<br>    {<br>        // ...<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_15" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086114">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:34</span>&nbsp;&nbsp;</div>
			<div class="postText2">原则5.3 使用安全管理器来检查保护敏感操作<br>说明：当与非信任代码（非产品包中的代码）交互时，敏感操作必须由 SecurityManager来检查控制。<br>错误示例：<br>public class SensitiveHash<br>{<br>    Hashtable&lt;Integer, String&gt; ht = new Hashtable&lt;Integer, String&gt;();<br>    <br>    public void removeEntry(Object key)<br>    {<br>        ht.remove(key);<br>    }<br>}<br>这段不符合要求的示例代码实例化一个Hashtable，并定义了一个removeEntry（）方法允许删除其条目。这种方法被认为是敏感的，因为哈希表中包含敏感信息。由于该方法被声明为是public的，这使其被暴露给了恶意的调用者。<br>推荐做法：<br>public class SensitiveHash<br>{<br>    Hashtable&lt;Integer, String&gt; ht = new Hashtable&lt;Integer, String&gt;();<br>    <br>    void removeEntry(Object key)<br>    {<br>        check("removeKeyPermission");<br>        ht.remove(key);<br>    }<br>    <br>    private void check(String directive)<br>    {<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null)<br>        {<br>            sm.checkSecurityAccess(directive);<br>        }<br>    }    <br>}<br>使用安全管理器检查来防止Hashtable实例中的条目被恶意删除。SecurityManager.checkSecurityAccess()方法检查调用者是否有特定的操作权限。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_16" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086111">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:33</span>&nbsp;&nbsp;</div>
			<div class="postText2">原则5.2 禁止基于不信任的数据源做安全检查<br>说明：基于不受信任数据的安全检查可以被攻击者所绕过。在做安全检查之前，可以先对不受信任的对象或者参数做防御性拷贝，然后基于这份拷贝做安全检查。这样的拷贝必须要是深拷贝。不建议使用clone()方法进行拷贝，因为待检查对象的clone()方法实现可能只是生成一个浅拷贝，另外clone()方法的实现本身可能就是由攻击者所提供。<br>错误示例：<br>public RandomAccessFile openFile(final java.io.File f)<br>{<br>    askUserPermission(f.getPath());<br>    // ...<br>    return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;()<br>    {<br>        public Object run()<br>        {<br>            return new RandomAccessFile(f, f.getPath());<br>        }<br>    });<br>}<br>这个不符合要求的示例代码描述了Java 1.5 版本 java.io 包中的安全漏洞。在此版本中，java.io.File类不是final类，它允许攻击者继承这个类并将攻击代码注入到子类的getPath()方法中。在这种方式下，覆盖getPath()方法以后，通过检查方法被调用的次数，函数第一次被调用时返回一个能够通过安全检查的文件路径，但第二次被调用时返回保存敏感信息的文件，如 /etc/passwd 文件，这样就绕过了安全检查。攻击代码可以写成这样：<br>public class BadFile extends java.io.File<br>{<br>    private int count;<br>    <br>    public String getPath()<br>    {<br>        return (++count == 1) ? "/tmp/foo" : "/etc/passwd";<br>    }<br>}<br>推荐做法：<br>public RandomAccessFile openFile(java.io.File f)<br>{<br>    final java.io.File copy = new java.io.File(f.getPath());<br>    askUserPermission(copy.getPath());<br>    // ...<br>    return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;()<br>    {<br>        public Object run()<br>        {<br>            return new RandomAccessFile(copy, copy.getPath());<br>        }<br>    });<br>}<br>在上面的代码中，通过java.io.File的构造函数创建了原始参数对象的一份拷贝，这样做可以保证在这份拷贝上调用的方法实现都是来自标准类库中的java.io.File类，而不是被攻击者所覆盖过的方法实现。注意，这里没有用f.clone()方法来进行拷贝操作，是因为f.clone()可能由攻击者所实现。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_17" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086109">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:32</span>&nbsp;&nbsp;</div>
			<div class="postText2">台安全<br>原则5.1 防止特权区域内出现不合法的数据<br>说明：当与非信任代码（非产品包中的代码）交互时，需要对输入的数据进行合法性和有效性进行校验。不要在特权块内操作未经校验的或者非信任的数据。如果违反，攻击者可以通过提供恶意输入来提升自己的权限。通过硬编码方式（即不通过参数输入数据）或者是在进行特权操作之前进行数据校验，可以减小这种风险。<br>错误示例：<br>private void privilegedMethod(final String filename) throws FileNotFoundException<br>{<br>    try<br>    {<br>        FileInputStream fis = (FileInputStream) AccessController.doPrivileged(<br>                new PrivilegedExceptionAction()<br>        {<br>            public FileInputStream run() throws FileNotFoundException<br>            {<br>                return new FileInputStream(filename);<br>            }<br>        });<br>        // do something with the file and then close it<br>    }<br>    catch (PrivilegedActionException e)<br>    {<br>       // forward to handler<br>    }<br>}<br><br>示例代码接受一个未经校验的非信任文件名作为参数。攻击者可以通过将受保护的文件路径传入，从而使得攻击者得到特权访问这些文件。<br>推荐做法： 硬编码文件路径<br>static final String FILEPATH = "/path/to/protected/file/fn.ext";<br><br>private void privilegedMethod() throws FileNotFoundException<br>{<br>    try<br>    {<br>        FileInputStream fis = (FileInputStream) <br>        AccessController.doPrivileged(new PrivilegedExceptionAction()<br>        {<br>            public FileInputStream run() throws FileNotFoundException<br>            {<br>                return new FileInputStream(FILEPATH);<br>            }<br>        });<br>        // do something with the file and then close it<br>    }<br>    catch (PrivilegedActionException e)<br>    {<br>        // forward to handler and log<br>    }<br>}<br>允许一个非特权用户访问任意的受保护文件或其他资源本身就是不安全的设计。可以考虑硬编码资源名称，或者是只允许用户在一个特定的资源列表里面做选择。上面的代码中将可以特权访问的文件路径硬编码在代码中。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_18" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086107">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:32</span>&nbsp;&nbsp;</div>
			<div class="postText2">则4.3 防止序列化和反序列化被利用来绕过安全管理<br>说明：序列化和反序列化可能被利用来绕过安全管理器的检查。如果一个类的构造器中因为种种原因需要引入安全管理器的检查，那么这种安全管理器的检查必须应用到所有涉及到实例化该类对象的地方，比如反序列化方法readObject()中。同样的，如果一个类中的字段访问方法中用到安全管理器检查，那么该检查也必须应用到该类的序列化方法writeObject()中。<br>错误示例：<br>public final class Hometown implements Serializable<br>{<br>    // Private internal state <br>    private String town;<br>    <br>    private static final String UNKNOWN = "UNKNOWN";<br>    <br>    void performSecurityManagerCheck() throws AccessDeniedException<br>    {<br>        // . . .<br>    }<br>    <br>    void validateInput(String newCC) throws InvalidInputException<br>    {<br>        // . . .<br>    }<br>    <br>    public Hometown()<br>    {<br>        performSecurityManagerCheck();<br>        // Initialize town to default value<br>        town = UNKNOWN;<br>    }<br>    <br>    // Allows callers to retrieve internal state<br>    String getValue()<br>    {<br>        performSecurityManagerCheck();<br>        return town;<br>    }<br>    <br>    // Allows callers to modify (private) internal state<br>    public void changeTown(String newTown)<br>    {<br>        if (town.equals(newTown))<br>        {<br>            // No change<br>            return;<br>        }<br>        else<br>        {<br>            performSecurityManagerCheck();<br>            validateInput(newTown);<br>            town = newTown;<br>        }<br>    }<br>    <br>    private void writeObject(ObjectOutputStream out) throws IOException<br>    {<br>        out.writeObject(town);<br>    }<br>    <br>    private void readObject(ObjectInputStream in) throws IOException<br>    {<br>        in.defaultReadObject();<br>        // If the deserialized name does not match<br>        // the default value normally<br>        // created at construction time, duplicate the checks<br>        if (!UNKNOWN.equals(town))<br>        {<br>            validateInput(town);<br>        }<br>    }<br>}<br>security manager checks在构造器中被使用，在序列化-反序列化的writeObject()和readObject()方法中没有用到，这样会允许非信任代码恶意创建实例。<br>推荐做法：<br>正确做法是在所有构造函数，以及可以修改或检索内部数据的方法中都需要security manager checks。这样一来，攻击者就不能用反序列化来修改对象的实例或者读字节流来泄露序列化的数据。<br>public final class Hometown implements Serializable<br>{<br>    // ... all methods the same except the following: <br>    // writeObject() correctly enforces checks during serialization <br>    private void writeObject(ObjectOutputStream out) throws IOException<br>    {<br>        performSecurityManagerCheck();<br>        out.writeObject(town);<br>    }<br>    <br>    // readObject() correctly enforces checks during deserialization <br>    private void readObject(ObjectInputStream in) throws IOException<br>    {<br>        in.defaultReadObject();<br>        // If the deserialized name does not match the default value normally <br>        // created at construction time, duplicate the checks <br>        if (!UNKNOWN.equals(town))<br>        {<br>            performSecurityManagerCheck();<br>            validateInput(town);<br>        }<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_19" href="https://www.cnblogs.com/chenyankai/p/3951606.html#3086106">Re:源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name</a> <span class="postDesc2">hunyihun 2014-12-15 11:32</span>&nbsp;&nbsp;</div>
			<div class="postText2">原则4.2 禁止序列化未加密的敏感数据<br>说明：虽然序列化可以将对象的状态保存为一个字节序列，之后通过反序列化该字节序列又能重新构造出原来的对象,但是它并没有提供一种机制来保证数据的安全性，敏感数据序列化之后是潜在对外暴露着的，攻击者既可以从中获取到敏感的信息，也可以恶意修改其中的数据，试图在其被反序列化之后来对系统造成危害。永远不应该被序列化的敏感信息包括：密钥、数字证书、以及那些包含敏感信息引用的类。此条规则的意义在于预防无意中敏感数据被通过序列化的方式暴露出去。<br>错误示例：<br>public class Point implements Serializable<br>{<br>    private double x;<br>    <br>    private double y;<br>    <br>    public Point(double x, double y)<br>    {<br>        this.x = x;<br>        this.y = y;<br>    }<br>    <br>    public Point()<br>    {<br>        // no-argument constructor <br>    }<br>}<br><br>public class Coordinates<br>{<br>    public static void main(String[] args)<br>    {<br>        FileOutputStream fout = null;<br>        try<br>        {<br>            Point p = new Point(5, 2);<br>            fout = new FileOutputStream("point.ser");<br>            ObjectOutputStream oout = new ObjectOutputStream(fout);<br>            oout.writeObject(p); //直接序列化，没有加密<br>            oout.close();<br>        }<br>        catch (Throwable t)<br>        {<br>            // Forward to handler <br>        }<br>        finally<br>        {<br>            if (fout != null)<br>            {<br>                try<br>                {<br>                    fout.close();<br>                }<br>                catch (IOException x)<br>                {<br>                    // handle error <br>                }<br>            }<br>        }<br>    }<br>}<br>在这段示例代码中假定坐标信息是敏感的，那么将其序列化到字节流中使之面临敏感信息泄露与被恶意篡改的风险。<br>推荐做法：通过transient 关键字保证敏感数据不被序列化<br>public class Point implements Serializable<br>{<br>    private transient double x; // transient表示这个数据不被序列化<br>    <br>    private transient double y; // declared transient <br>    <br>    public Point(double x, double y)<br>    {<br>        this.x = x;<br>        this.y = y;<br>    }<br>    <br>    public Point()<br>    {<br>        // no-argument constructor <br>    }<br>}<br>对于一个类中属于敏感信息的那部分，在进行序列化的时候应该将他们排除在外。这可以通过如上例中将这些字段声明为transient来实现，也可以通过自定义writeObject()、writeReplace()、writeExternal()这些方法，不将包含敏感信息的字段写到序列化字节流中。</div>				
		</div>
	<div class="line"></div>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=2">2</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;6&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">下一页</a>&nbsp;
</div></div>
</div>


			</td>
		</tr>
		</tbody></table>
	</td>
	<td width="10">&nbsp;</td>
	<td valign="top">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
			<table width="100%" height="200">
			<tbody><tr>
				<td><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/09/01&#39;);return false;">&lt;</a></td><td align="center">2018年10月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/11/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td class="CalWeekendDay" align="center">6</td></tr><tr><td class="CalWeekendDay" align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td class="CalWeekendDay" align="center">13</td></tr><tr><td class="CalWeekendDay" align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalWeekendDay" align="center">20</td></tr><tr><td class="CalWeekendDay" align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">24</td><td align="center">25</td><td align="center">26</td><td class="CalWeekendDay" align="center">27</td></tr><tr><td class="CalWeekendDay" align="center">28</td><td align="center">29</td><td align="center">30</td><td align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></td>
			</tr>
			</tbody></table>
				
<h1>&nbsp;公告</h1><br>
<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/chenyankai/">hunyihun</a><br>园龄：<a href="https://home.cnblogs.com/u/chenyankai/" title="入园时间：2013-11-13">4年10个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/chenyankai/followers/">0</a><br>关注：<a href="https://home.cnblogs.com/u/chenyankai/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;bb2fa9a6-374c-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('bb2fa9a6-374c-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
	
				
<h1>&nbsp;导航</h1>
<ul class="list" type="square">
	<li class="listitem"><a id="blog_nav_sitehome" class="listitem" href="https://www.cnblogs.com/">博客园</a></li>
	<li class="listitem"><a id="blog_nav_myhome" class="listitem" href="https://www.cnblogs.com/chenyankai/">首页</a></li>
	<li class="listitem"><a id="blog_nav_newpost" class="listitem" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">发新随笔</a></li>
	<li class="listitem"><a id="MyLinks1_NewArticleLink" class="listitem" href="https://www.cnblogs.com/EnterMyBlog.aspx?NewArticle=1">发新文章</a></li>
	<li class="listitem"><a id="blog_nav_contact" accesskey="9" class="listitem" rel="nofollow" href="https://msg.cnblogs.com/send/hunyihun">联系</a></li>
	<li class="listitem"><a id="blog_nav_rss" class="listitem" href="https://www.cnblogs.com/chenyankai/rss">订阅</a><a id="blog_nav_rss_image" href="https://www.cnblogs.com/chenyankai/rss"><img src="./最新评论 - hunyihun - 博客园6_files/xml.gif" alt="订阅"></a>
	</li><li class="listitem"><a id="blog_nav_admin" class="listitem" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

				<div id="blog_stats">
<h1>&nbsp;统计</h1>
	<ul class="list" type="square">
		<li class="listitem">随笔： 2
		</li><li class="listitem">文章： 0
		</li><li class="listitem">评论： 155
		</li><li class="listitem">引用： 0
	</li>
</ul></div>
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/chenyankai/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="https://www.cnblogs.com/chenyankai/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="https://www.cnblogs.com/chenyankai/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">

</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
		<h1 class="listtitle">随笔档案</h1>
		
				<ul class="list" type="square">
			
				<li class="listitem"><a id="CatList_LinkList_0_Link_0" class="listitem" href="https://www.cnblogs.com/chenyankai/archive/2014/09.html">2014年9月 (2)</a> </li>
			
				</ul>
			
	
</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<h3 class="catListTitle">最新评论</h3>
<div class="RecentComment" id="RecentComments">
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097337">1. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">使用强随机数说明：安全敏感的代码块（如SessionID的生成、挑战算法中的随机数生成等），必须采用强随机数，禁止使用伪随机数。Java API 提供了伪随机数生成器（PRNG）——java.util......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097329">2. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">原则7.3 基于哈希算法的口令安全存储必须加入盐值（salt）说明：单向哈希是在一个方向上工作的哈希函数，从预映射的值很容易计算其哈希值，但要根据特定哈希值产生一个预映射的值却是非常困难的。单向哈希主......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097327">3. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">7.	其它原则7.1 禁止在日志中保存口令、密钥说明： 在日志中不能保存口令和密钥，其中的口令包括明文口令和密文口令。对于敏感信息建议采取以下方法，1）不打印在日志中；2）若因为特殊原因必须要打印日志......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097326">4. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">避免依赖和信任环境变量说明：使用环境变量会带来可以移植性问题，在不同的操作系统中其语义可能有所不同。因此要尽量避免使用环境变量。对于一个值如果有定义的系统属性(System properties)可用......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097325">5. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">所有安全相关的敏感代码都放在一个jar包中，并签名再加密说明：若安全相关的敏感代码（例如进行权限控制或者用户名密码校验的代码）没有放到同一个受信任的jar包中，攻击者可以通过先加载恶意代码（使用相同的......</li>
        <li class="recent_comment_author">--hunyihun</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<h3 class="catListTitle">阅读排行榜</h3>
<div class="RecentComment" id="TopViewPosts"> 
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(67)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(15)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<h3 class="catListTitle">评论排行榜</h3>
<div class="RecentComment" id="TopCommentsPosts">
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(97)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(58)</a></li></ul></div>
</div></div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap" style="display: none;">
<h3 class="catListTitle">推荐排行榜</h3>
<div class="RecentComment">
	<div id="TopDiggPostsBlock"></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			<br>
			
<div class="footer">
	Powered by: <a href="http://www.cnblogs.com/">博客园</a><br>模板提供：<a href="http://blog.hjenglish.com/">沪江博客</a><br>
	Copyright ©2018 hunyihun
</div>
			</td>
		</tr>
		</tbody></table>
	</td>
</tr>
</tbody></table>
<br>



</body></html>