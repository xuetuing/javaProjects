<!DOCTYPE html>
<!-- saved from url=(0061)https://www.cnblogs.com/chenyankai/recentcomments.html?page=2 -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<title>最新评论 - hunyihun - 博客园</title>
<link type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园2_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园2_files/bundle-classic.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./最新评论 - hunyihun - 博客园2_files/bundle-classic-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/chenyankai/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/chenyankai/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/chenyankai/wlwmanifest.xml">
<script async="" src="./最新评论 - hunyihun - 博客园2_files/analytics.js.下载"></script><script src="./最新评论 - hunyihun - 博客园2_files/jquery-2.2.0.min.js.下载"></script>
<script type="text/javascript">var currentBlogApp = 'chenyankai', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./最新评论 - hunyihun - 博客园2_files/blog-common.js.下载" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<table align="center" width="98%" cellspacing="0" cellpadding="0" border="0" style="margin-top:10px">
<tbody><tr>
	<td valign="top" width="70%" style="padding:0">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
<div id="header">
	<span>
		<a id="Header1_HeaderTitle" href="https://www.cnblogs.com/chenyankai/">hunyihun</a><br>
		<div class="sub"></div>
	</span>
</div>
			</td>
		</tr>
		</tbody></table>
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white" class="index">
		<tbody><tr>
			<td class="main">
			

<div id="myposts">
<h3 class="myposts_title">最新评论</h3>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;2&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">下一页</a>&nbsp;
</div></div>

		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_0" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097278">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:20</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止在单个输入流InputStream上创建多份buffered wrapper<br>说明：Java中的输入流，可以对另一个输入流进行缓冲封装，以便提供更加高效的I/O,例如,Scanner和BufferedInputStream。用于外层封装的流我们称之为wrapper。如果wrapper支持预读(look-ahead)，那么在单个输入流之上创建和使用多个这样的wrapper将会使得程序的行为不可预期。这一点可以被攻击者所利用。例如，攻击者可以在控制台或者是使用System.setIn()方法对System.in进行重定向（从文件）。一般来说，支持缓冲I/O的InputStream都很容易受此形式的滥用。<br>错误示例：<br>public class InputLibrary<br>{<br>    public static char getChar() throws EOFException, IOException<br>    {<br>        // wrapper<br>        BufferedInputStream in = new BufferedInputStream(System.in);<br>        int input = in.read();<br>        if (input == -1)<br>        {<br>            throw new EOFException();<br>        }<br>        // Down casting is permitted because InputStream<br>        // guarantees read() in range<br>        // 0..255 if it is not −1<br>        return (char) input;<br>    }<br>    <br>    public static void main(String[] args)<br>    {<br>        try<br>        {<br>            // Either redirect input from the console or use<br>            // System.setIn(new FileInputStream("input.dat"));<br>            System.out.print("Enter first initial: ");<br>            char first = getChar();<br>            System.out.println("Your first initial is " + first);<br>            System.out.print("Enter last initial: ");<br>            char last = getChar();<br>            System.out.println("Your last initial is " + last);<br>        }<br>        catch (EOFException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>        catch (IOException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>    }<br>}<br>上面的代码中，每次调用getChar()方法都会对System.in封装出一个新的BufferedInputStream，且getChar()方法中的in.read()调用会对System.in进行预读以填充in中的缓冲区，导致下次再调getChar()方式时前一次预读的字节被丢失。<br>推荐做法：将BufferedInputStream对象作为类变量，以便复用。<br>public class InputLibrary<br>{<br>    private static BufferedInputStream in = new BufferedInputStream(System.in);<br>    <br>    public static char getChar() throws EOFException, IOException<br>    {<br>        int input = in.read();<br>        if (input == -1)<br>        {<br>            throw new EOFException();<br>        }<br>        in.skip(1); // This statement is to advance to the next line<br>        // The noncompliant code example deceptively<br>        // appeared to work without it (in some cases)<br>        return (char) input;<br>    }<br>    <br>    public static void main(String[] args)<br>    {<br>        try<br>        {<br>            System.out.print("Enter first initial: ");<br>            char first = getChar();<br>            System.out.println("Your first initial is " + first);<br>            System.out.print("Enter last initial: ");<br>            char last = getChar();<br>            System.out.println("Your last initial is " + last);<br>        }<br>        catch (EOFException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>        catch (IOException e)<br>        {<br>            System.err.println("ERROR");<br>            // Forward to handler<br>        }<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_1" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097276">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:20</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止将wrap()和duplicate()创建的buffer暴露给不受信任代码<br>说明：java.nio包中的一些Buffer类，例如IntBuffer、CharBuffer、以及ByteBuffer,定义了各种wrap()方法用来将基本类型的数组包装成对应的Buffer类型，对包装后得到的Buffer对象的修改也会反映到原始的数组上。同样，对使用duplicate()方法复制的出Buffer对象的修改也会反映到原始的Buffer上。将wrap()和duplicate()方法返回的Buffer暴露给不受信任的代码(非产品包中的代码)，存在原始数据可以被恶意修改的风险。为了防止此类问题发生，可以对外提供一个该Buffer的只读视图对象，或者是对外返回一份该Buffer的拷贝。<br>错误示例：<br>public class Wrap<br>{<br>    private char[] dataArray;<br>    <br>    public Wrap()<br>    {<br>        dataArray = new char[10];<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return CharBuffer.wrap(dataArray);<br>    }<br>}<br>public class Dup<br>{<br>    CharBuffer cb;<br>    <br>    public Dup()<br>    {<br>        cb = CharBuffer.allocate(10);<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return cb.duplicate();<br>    }<br>}<br>示例代码中getBufferCopy()方法的实现对外提供了对原始CharBuffer的访问。<br>推荐做法：getBufferCopy()方法返回一个原始CharBuffer的只读视图。<br>public class Wrap<br>{<br>    private char[] dataArray;<br>    <br>    public Wrap()<br>    {<br>        dataArray = new char[10];<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return CharBuffer.wrap(dataArray).asReadOnlyBuffer();<br>    }<br>}<br>public class Dup<br>{<br>    CharBuffer cb;<br>    <br>    public Dup()<br>    {<br>        cb = CharBuffer.allocate(10);<br>        // Initialize<br>    }<br>    <br>    public CharBuffer getBufferCopy()<br>    {<br>        return cb.asReadOnlyBuffer();<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_2" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097274">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:19</span>&nbsp;&nbsp;</div>
			<div class="postText2">3.	IO操作<br>规则3.1 临时文件使用完毕应及时删除<br>说明：临时文件可能包含敏感数据，为防止可能的未授权访问，需保证临时文件在使用完毕前被删除。<br>错误示例：在结束时没有删除创建的临时文件。<br>public class TempFile<br>{<br>    public static void main(String[] args) throws IOException<br>    {<br>        File f = new File("tempnam.tmp");<br>        if (f.exists())<br>        {<br>            System.out.println("This file already exists");<br>            return;<br>        }<br>        FileOutputStream fop = null;<br>        try<br>        {<br>            fop = new FileOutputStream(f);<br>            String str = "Data";<br>            fop.write(str.getBytes());<br>        }<br>        finally<br>        {<br>            if (fop != null)<br>            {<br>                try<br>                {<br>                    fop.close();<br>                }<br>                catch (IOException x)<br>                {<br>                    // handle error<br>                }<br>            }<br>        }<br>    }<br>}<br>推荐做法1：<br>public class TempFile<br>{<br>    public static void main(String[] args)<br>    {<br>        Path tempFile = null;<br>        try<br>        {<br>            tempFile = Files.createTempFile("tempnam", ".tmp");<br>            try (BufferedWriter writer = Files.newBufferedWriter(tempFile,<br>                    Charset.forName("UTF8"), StandardOpenOption.DELETE_ON_CLOSE))<br>            {<br>                // write to file<br>            }<br>            System.out.println("Temporary file write done, file erased");<br>        }<br>        catch (FileAlreadyExistsException x)<br>        {<br>            System.err.println("File exists: " + tempFile);<br>        }<br>        catch (IOException x)<br>        {<br>            // Some other sort of failure, such as permissions.<br>            System.err.println("Error creating temporary file: " + x);<br>        }<br>    }<br>}<br>该示例代码使用了 Java SE 7 的 NIO2 包中的几个方法创建了一个临时文件，使用的是 createTempFile() 方法，它创建一个不可预知的名字。使用try-with-resources结构打开文件，不管是否有异常该结构都会自动关闭文件。最后，文件是用 Java SE 7 的 DELETE_ON_CLOSE 选项打开的，这使得在文件关闭时自动删除。如果是jdk1.7之前的版本，则需在临时文件使用之后主动删除。<br>推荐做法2：<br>public class TempFile<br>{<br>    public static void main(String[] args) throws IOException<br>    {<br>        File f = File.createTempFile("tempnam", ".tmp");<br>        FileOutputStream fop = null;<br>        try<br>        {<br>            fop = new FileOutputStream(f);<br>            String str = "Data";<br>            fop.write(str.getBytes());<br>            fop.flush();<br>        }<br>        finally<br>        {<br>            if (fop != null)<br>            {<br>                try<br>                {<br>                    fop.close();<br>                    f.delete(); //delete file when finished<br>                }<br>                catch (IOException x)<br>                {<br>                    // handle error<br>                }<br>            }<br>        }<br>    }  <br>}<br>如果使用的是JDK1.7之前的版本，可以自己编写代码实现临时文件在使用完之后对其进行删除。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_3" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097272">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:17</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止不受信任的代码直接终止JVM<br>说明：调用System.exit()来终止Java虚拟机（JVM）会终止所有正在运行的程序和线程。这可能会导致拒绝服务（DoS）攻击。例如，攻击者将System.exit()嵌入到JSP代码中可以使Web服务器终止，阻止继续为用户提供服务。程序必须防止无意和恶意调用System.exit（）。此外，当操作系统发出强行终止指令（例如，通过使用Windows任务管理器，POSIX kill命令，或其他机制）时，程序应该进行必要的清理。这里的非信任代码可以理解为非产品包中的代码。<br>错误示例：<br>public class InterceptExit<br>{<br>    public static void main(String[] args)<br>    {<br>        // ...<br>        System.exit(1); // Abrupt exit<br>        System.out.println("This never executes");<br>    }<br>}<br>上面代码对于使用System.exit()强制关闭JVM缺乏安全管理，它未对是否允许调用System.exit()进行检查。<br>推荐做法：<br>class PasswordSecurityManager extends SecurityManager<br>{<br>    private boolean isExitAllowedFlag;<br>    <br>    public PasswordSecurityManager()<br>    {<br>        super();<br>        isExitAllowedFlag = false;<br>    }<br>    <br>    public boolean isExitAllowed()<br>    {<br>        return isExitAllowedFlag;<br>    }<br>    <br>    @Override<br>    public void checkExit(int status)<br>    {<br>        if (!isExitAllowed())<br>        {<br>            throw new SecurityException();<br>        }<br>        super.checkExit(status);<br>    }<br>    <br>    public void setExitAllowed(boolean f)<br>    {<br>        isExitAllowedFlag = f;<br>    }<br>}<br><br>public class InterceptExit<br>{<br>    public static void main(String[] args)<br>    {<br>        PasswordSecurityManager secManager = new PasswordSecurityManager();<br>        System.setSecurityManager(secManager);<br>        try<br>        {<br>            // ...<br>            System.exit(1); // Abrupt exit call<br>        }<br>        catch (Throwable x)<br>        {<br>            if (x instanceof SecurityException)<br>            {<br>                System.out.println("Intercepted System.exit()");<br>                // Log exception<br>            }<br>            else<br>            {<br>                // Forward to exception handler<br>            }<br>        }<br>        // ...<br>        secManager.setExitAllowed(true); // Permit exit<br>        // System.exit() will work subsequently<br>        // ...<br>    }<br>}<br>安装了一个自定义的安全管理器：PasswordSecurityManager,重写checkExit()方法，增加了对一个内部标记位isExitAllowedFlag的判断，作为System.exit()操作被允许的一个必要条件，若该条件不满足，则对System.exit()的调用会抛出SecurityException（实际是checkExit()方法所抛出）。该标记位的初始值为false,只有执行了必要的清理工作后，才将该标记位设为true, setExitAllowed()用来设置该标记位。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_4" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097270">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:17</span>&nbsp;&nbsp;</div>
			<div class="postText2">记录日志时避免抛异常<br>说明：如果记录日志时有异常抛出，很可能导致记录日志失败，日志记录失败有可能带来安全风险。例如：攻击者可以通过该漏洞隐瞒关键的安全异常，防止被记录。为了保证日志记录成功，程序必须保证记录日志时不会产生异常，或者即使有异常抛出，也要保证日志记录成功。<br>错误示例：<br>try<br>{<br>    // ...<br>}<br>catch (SecurityException se)<br>{<br>System.err.println(se);<br>    // Recover from exception<br>}<br>标准的错误流System.err并不适合用来记录异常日志。首先，流可能被用尽或者被关闭，另一方面，用错误流来记录一些与安全相关的异常容易泄露敏感信息。当用流来记录异常信息时发生I/O错误，则会抛出一个IOException，这会导致原始的异常信息被丢失。<br>推荐做法：记录日志时应保证不会产生异常。<br>try<br>{<br>    // ...<br>}<br>catch (SecurityException se)<br>{<br>    logger.log(Level.SEVERE, se.toString());<br>    // Recover from exception<br>}<br>使用标准的日志记录工具来记录异常信息。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_5" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097269">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:17</span>&nbsp;&nbsp;</div>
			<div class="postText2">推荐做法1：<br>public class ExceptionExample<br>{<br>    public static void main(String[] args)<br>    {<br>        File file = null;<br>        try<br>        {<br>            file = new File(System.getenv("APPDATA") + args[0]).getCanonicalFile();<br>            if (!file.getPath().startsWith("c:\\homepath"))<br>            {<br>                System.out.println("Invalid file");<br>                return;<br>            }<br>        }<br>        catch (IOException x)<br>        {<br>            System.out.println("Invalid file");<br>            return;<br>        }<br>        try<br>        {<br>            FileInputStream fis = new FileInputStream(file);<br>        }<br>        catch (FileNotFoundException x)<br>        {<br>            System.out.println("Invalid file");<br>            return;<br>        }<br>    }<br>}<br>上面代码采取了一种安全策略，只允许用户访问”c:\homepath”中的文件，而”c:\homepath”以外的文件则是对用户隐藏的。当用户试图访问”c:\homepath”以外的文件或者无效的文件路径时，程序只是给出了一个简洁的提示信息。<br>推荐做法2：<br>public class ExceptionExample<br>{<br>    public static void main(String[] args)<br>    {<br>        FileInputStream fis = null;<br>        try<br>        {<br>            switch (Integer.valueOf(args[0]))<br>            {<br>                case 1:<br>                    fis = new FileInputStream("c:\\homepath\\file1");<br>                    break;<br>                case 2:<br>                    fis = new FileInputStream("c:\\homepath\\file2");<br>                    break;<br>                //...<br>                default:<br>                    System.out.println("Invalid option");<br>                    break;<br>            }<br>        }<br>        catch (Throwable t)<br>        {<br>            MyExceptionReporter.report(t); // Sanitize<br>        }<br>    }<br>}<br>限制用户输入,只有c:\homepath\file1和c:\homepath\file2允许被用户打开，当发生异常时通过MyExceptionReporter.report()对异常中的敏感信息进行过滤清理。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_6" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097261">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:15</span>&nbsp;&nbsp;</div>
			<div class="postText2">2.	异常行为<br>原则2.1 禁止在异常中暴露敏感信息<br>说明：这里所说的暴露敏感信息，主要是指直接向外部暴露服务器端的敏感信息。传递异常时往往会导致敏感信息泄漏（敏感信息包括但不限于：口令、密钥、证书、会话标识、License、隐私数据（如短消息的内容）、授权凭据、个人数据（如姓名、住址、电话等）等，在程序文件、配置文件、日志文件、备份文件及数据库中都有可能包含敏感信息），如果没有过滤敏感信息，可能有助于攻击者发起进一步攻击，攻击者可能会构造输入参数进一步挖掘应用程序的内部结构和实现机制。需要注意的是不只是异常中的文本描述信息会产生信息泄露，异常本身的类型信息也会导致信息泄露。<br>错误示例1：异常信息和类型泄露 <br>public class ExceptionExample<br>{<br>    public static void main(String[] args) throws FileNotFoundException<br>    {<br>        // Linux stores a user's home directory path in<br>        // the environment variable $HOME, Windows in %APPDATA%<br>        FileInputStream fis = new FileInputStream(System.getenv("APPDATA")<br>                + args[0]);<br>    }  <br>}<br>当用户请求的目录不存在时，上面的代码会抛出FileNotFoundException异常，并且将目录结构信息包含在异常信息中。攻击者可以采用该方法不断伪造文件路径来重现文件系统的结构。<br>错误示例2：包装并重新抛出敏感类型异常<br>try<br>{<br>    FileInputStream fis = new FileInputStream(System.getenv("APPDATA")<br>                    + args[0]);<br>}<br>catch (FileNotFoundException e)<br>{<br>    // Log the exception<br>    throw new IOException("Unable to retrieve file", e);<br>}<br>上面代码抛出的IOException中封装了原始的异常，攻击者仍然可以通过它获取到文件系统的敏感信息。<br>错误示例3：清理异常<br>class SecurityIOException extends IOException<br>{/* ... */<br>};<br><br>// ...<br>try<br>{<br>FileInputStream fis = new FileInputStream(System.getenv("APPDATA") + args[0]);<br>}<br>catch (FileNotFoundException e)<br>{<br>// Log the exception<br>    throw new SecurityIOException();<br>}<br>虽然该示例比错误示例2泄露敏感信息的可能性要小，但是由于程序对传入的有效路径和无效路径的反应不同(前者不会抛异常，后者会抛出异常)，攻击者能够以此推测出文件系统的敏感信息。程序没有对用户的输入做限制，使得系统易受暴力攻击，攻击者可以通过输入所有可能的文件名的方式来发现有效的文件路径。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_7" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097259">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:14</span>&nbsp;&nbsp;</div>
			<div class="postText2">对ZipInputStream中文件条目的大小做检查和限制<br>说明：ZIP压缩格式可以做到很高的压缩率。如果一个zip文件中的条目解压之后的大小超过了一定的上限，则应该拒绝对其进行解压，否则容易导致系统资源占用过多，形成拒绝服务攻击和zip炸弹。该规则不仅仅限定于zip格式，其它jar、rar等格式也是同样如此。此外，对普通的文件上传，文件大小也是需要控制的，否则对服务器磁盘空间资源的占用也有很大的影响。<br>错误示例：<br>static final int BUFFER = 512;<br>// ...<br>// external data source: filename<br>     BufferedOutputStream dest = null;<br>     FileInputStream fis = new FileInputStream(filename);<br>     ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));<br>     ZipEntry entry;<br>     while ((entry = zis.getNextEntry()) != null)<br>     {<br>         System.out.println("Extracting: " + entry);<br>         int count;<br>         byte data[] = new byte[BUFFER];<br>         // write the files to the disk<br>         FileOutputStream fos = new FileOutputStream(entry.getName());<br>         dest = new BufferedOutputStream(fos, BUFFER);<br>         while ((count = zis.read(data, 0, BUFFER)) != -1)<br>         {<br>            dest.write(data, 0, count);<br>         }<br>         // ...<br>     }<br>// ...<br>上面的代码未对解压出来的文件大小做判断和限制，恶意用户提供的包含巨大条目的zip文件会导致一直进行解压操作直到结束或者是资源被耗尽。<br>推荐做法：校验输入文件<br>static final int BUFFER = 512;<br>static final int TOOBIG = 0x6400000; // 100MB<br>// ...<br>// external data source: filename<br>    BufferedOutputStream dest = null;<br>    FileInputStream fis = new FileInputStream(filename);<br>    ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));<br>    ZipEntry entry;<br>    try<br>    {<br>        while ((entry = zis.getNextEntry()) != null)<br>        {<br>            System.out.println("Extracting: " + entry);<br>            // write the files to the disk, but only if file is not insanely<br>            // big<br>            if (entry.getSize() &gt; TOOBIG)<br>            {<br>                throw new IllegalStateException(<br>                        "File to be unzipped is huge.");<br>            }<br>            if (entry.getSize() == -1)<br>            {<br>                throw new IllegalStateException(<br>                        "File to be unzipped might be huge.");<br>            }<br>            int count;<br>            byte data[] = new byte[BUFFER];<br>            // write the files to the disk<br>            FileOutputStream fos = new FileOutputStream(entry.getName());<br>            dest = new BufferedOutputStream(fos, BUFFER);<br>            while ((count = zis.read(data, 0, BUFFER)) != -1)<br>            {<br>                dest.write(data, 0, count);<br>            }<br>            // ...<br>        }<br>    }<br>   // ...<br><br>上面的代码在解压zip文件中的每个条目之前，使用entry.getSize()方法获取到条目的大小，当条目的大小超过100MB或者其大小不确定时(entry.getSize() == -1)抛出异常。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_8" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097257">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:14</span>&nbsp;&nbsp;</div>
			<div class="postText2">在对路径进行验证前应先对其做标准化<br>说明：路径在验证时会有很多干扰因素，如相对路径与绝对路径，路经中的“.”和“..”，路径中的符号链接、硬链接、快捷路径、别名等。另外，同一个文件可能有不同的表达方式，所以在验证路径时需要对路径进行标准化，使得路径表达唯一化后进行无歧义的比较。<br>如果没有作标准化处理，攻击者有机会：<br>构造一个跨越目录限制的文件路径，例如“../../../etc/passwd”或“../../../boot.ini”<br>构造指向系统关键文件的链接文件,例如symlink("/etc/shadow","/tmp/log")<br>通过上述两种方式之一可以实现读取或修改系统重要数据文件，威胁系统安全。<br>错误示例：<br>public static void main(String[] args)<br>    {<br>        File f = new File(System.getProperty("user.home")<br>                + System.getProperty("file.separator") + args[0]);<br>        String absPath = f.getAbsolutePath();<br>        // Validation<br>        /* … */<br>    }<br>getAbsolutePath()方法可以获取全路径，但不会将路径中的“..”处理掉。<br>推荐做法：<br>public static void main(String[] args) throws IOException<br>    {<br>        File f = new File(System.getProperty("user.home")<br>                + System.getProperty("file.separator") + args[0]);<br>        String canonicalPath = f.getCanonicalPath();<br>        // Validation<br>        /* ... */<br>    }<br>在验证路径之前应该用getCanonicalPath()对路径进行标准化，使得路径表达式唯一，无歧义。<br>延伸阅读材料: CVE-2008-2370、CVE-2005-0789、CVE-2008-5518</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_9" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097254">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:12</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止直接将外部输入传递给Runtime.exec()方法<br>说明：如果输入的数据不经审查就作为参数直接传递给Runtime.exec()方法，则容易形成命令行注入与参数注入攻击漏洞。命令行注入攻击只有在Runtime.exec()中调用了命令行解释器（如Windows中的cmd.exe和POSIX中的sh）的情况下才有可能发生，因为只有命令行解释器才能通过命令分隔符来执行多条命令。另外需要注意的是，当使用Runtime.exec()执行bat或者sh脚本时，会自动调用命令行解释器来执行。例如，当执行下面的语句:<br>Runtime.getRuntime().exec(“test.bat &amp; notepad.exe”);<br>由于对于bat脚本会默认使用cmd.exe来执行，后面的“&amp;”会被当做命令分隔符处理，test.bat和notepad.exe都会被执行。而对于参数注入攻击，当参数中包含空格、双引号、以“-”或者“/”开头来指定开关参数时都有可能发生。<br>错误示例：<br>class DirList<br>{<br>    public static void main(String[] args) throws Exception<br>    {<br>        String dir = System.getProperty("dir");<br>        Runtime rt = Runtime.getRuntime();<br>        Process proc = rt.exec("cmd.exe /C dir " + dir);<br>        // …<br>    }<br>}<br>对于上述代码，攻击者可以通过以下方式执行程序:<br>java –Ddir='dummy &amp; echo bad' DirList<br>则实际执行了两个命令:<br>dir dummy <br>echo bad<br>前一条命令尝试罗列目录的内容，后一条命令打印信息到控制台。<br>推荐做法1(避免Runtime.exec())：<br>class DirList<br>{<br>    public static void main(String[] args) throws Exception<br>    {<br>        File dir = new File(System.getProperty("dir"));<br>        if (!dir.isDirectory())<br>        {<br>            System.out.println("Not a directory");<br>        }<br>        else<br>        {<br>            for (String file : dir.list())<br>            {<br>                System.out.println(file);<br>            }<br>        }<br>      }<br>}<br>在有其他选择的情况下，请尽量避免使用Runtime.exec()执行命令行调用来完成一项任务。<br>推荐做法2(输入校验)：<br>// . ..<br>if (!Pattern.matches("[0-9A-Za-z@.]+", dir))<br>{<br>    // Handle error<br>}<br>// ...<br>当无法避免使用Runtime.exec()时，需对用户输入做校验或限制，防止其中包含一些命令分隔符或者重定向符（“&amp;&amp;”、“&amp;”、“||”、“|”），用于连续执行多个命令或者重定向输入输出。<br>延伸阅读材料：CVE-2010-0886、CVE-2010-1826</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_10" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097252">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:12</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止直接使用用户输入的数据来构造格式化字符串<br>说明：Java解释格式化字符串比较严格，当匹配对应的格式化字符，转换参数失败时，标准库会抛出异常，这种方式可以减少被恶意攻击的机会。但是恶意用户仍然可以通过格式化字符串注入引起信息泄露或者拒绝服务攻击。 因此，不能直接将来自不可信源的字符串用于构造格式化字符串。<br>错误示例：<br>class Format<br>{<br>    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);<br>    <br>    public static void main(String[] args)<br>    {<br>        // args[0] is the credit card expiration date<br>        // args[0] can contain either %1$tm, %1$te or %1$tY as malicious arguments<br>        // First argument prints 05 (May), second prints 23 (day)<br>        // and third prints 1995 (year)<br>        // Perform comparison with c, if it doesn't match print the following line<br>        System.out.printf(args[0]<br>                + " did not match! HINT: It was issued on %1$terd of some month",<br>                c);<br>    }<br>}<br>上面代码中，如果arg[0]包含恶意格式化字符串%1$tm,%1$te或者%1$tY，则会导致用来做比较验证的日期信息被暴露。<br>推荐做法：将用户的输入排除在格式化字符串之外<br>class Format<br>{<br>    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);<br>    <br>    public static void main(String[] args)<br>    {<br>        // args[0] is the credit card expiration date<br>        // Perform comparison with c,<br>        // if it doesn't match print the following line<br>        System.out.printf("%s did not match! "<br>                + " HINT: It was issued on %1$terd of some month", args[0], c);<br>    }<br>}</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_11" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097251">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:12</span>&nbsp;&nbsp;</div>
			<div class="postText2">对字符串校验之前先要对其做归一化<br>说明：对外部输入字符串校验之前，需要使用java.text.Normalizer的normalize()方法先对其进行归一化（Unicode Normalization）处理。归一化可以确保具有相同意义的字符串具有统一的二进制描述。推荐使用的归一化格式是NFKC，因为它将输入转换成可与目标进行安全比较的等效标准格式。<br>错误示例：<br>// String s may be user controllable<br>String s = "\uFE64" + "script" + "\uFE65";<br>// Validate<br>Pattern pattern = Pattern.compile("[&lt;&gt;]"); // Check for angle brackets<br>Matcher matcher = pattern.matcher(s);<br>if (matcher.find())<br>{<br>    // Found black listed tag<br>    throw new IllegalStateException();<br>}<br>// . . .<br>如上示例代码的本意是防止外部输入中包含正反尖括号: &lt; (\u003C)和 &gt; (\u003E)。但是在Unicode中正反尖括号还有另外一种非标准的表达方式：&lt; (\uFE64)和 &gt; (\uFE65)。攻击者可以利用这种非标准的表达方式来绕过输入检查。<br>推荐做法：<br>String s = "\uFE64" + "script" + "\uFE65";<br>// Normalize<br>// \uFE64 is normalized to &lt; and \uFE65 is normalized to &gt; using NFKC<br>s = Normalizer.normalize(s, Form.NFKC);<br>// Validate<br>Pattern pattern = Pattern.compile("[&lt;&gt;]");<br>Matcher matcher = pattern.matcher(s);<br>if (matcher.find())<br>{<br>    // Found black listed tag<br>    throw new IllegalStateException();<br>}<br>// . . .<br>在进行校验之前先对输入的字符串做归一化处理，可以将使用非标准表达方式的字符串转换成统一的标准表达形式，从而使其不能绕过输入校验。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_12" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097243">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:08</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止直接使用外部输入来拼接XML数据以防止XML注入<br>说明：构造XML节点时，当XML中包含有未经审查的用户输入时，可能会产生XML注入攻击。恶意攻击者伪造XML数据，改变XML的原有结构，达到攻击的目的。 <br>错误示例: <br>private void createXMLStream(BufferedOutputStream outStream, String quantity) throws IOException<br>    {<br>        String xmlString;<br>        xmlString = "&lt;item&gt;\n&lt;description&gt;Widget&lt;/description&gt;\n"<br>                + "&lt;price&gt;500.0&lt;/price&gt;\n" + "&lt;quantity&gt;" + quantity<br>                + "&lt;/quantity&gt;&lt;/item&gt;";<br>        outStream.write(xmlString.getBytes());<br>        outStream.flush();<br>    }<br>对这段示例代码,恶意用户可能为quantity输入：<br>"1&lt;/quantity&gt;&lt;price&gt;1.0&lt;/price&gt;&lt;quantity&gt;1"<br>从而XML 变成如下片段,XMP解析器可能取出的price为1,而不是500.0<br>&lt;item&gt;<br>    &lt;description&gt;Widget&lt;/description&gt;<br>    &lt;price&gt;500.0&lt;/price&gt;<br>    &lt;quantity&gt;1&lt;/quantity&gt;&lt;price&gt;1.0&lt;/price&gt;&lt;quantity&gt;1&lt;/quantity&gt;<br>&lt;/item&gt;<br>推荐做法：使用正则表达式对构成XML节点的数据进行校验。<br>private void createXMLStream(BufferedOutputStream outStream, String quantity) throws IOException<br>    {<br>        // Write XML string if quantity contains numbers only.<br>        // Blacklisting of invalid characters can be performed<br>        // in conjunction.<br>        if (!Pattern.matches("[0-9]+", quantity))<br>        {<br>            // Format violation<br>        }<br>        String xmlString = "&lt;item&gt;\n&lt;description&gt;Widget&lt;/description&gt;\n"<br>                + "&lt;price&gt;500&lt;/price&gt;\n" + "&lt;quantity&gt;" + quantity<br>                + "&lt;/quantity&gt;&lt;/item&gt;";<br>        outStream.write(xmlString.getBytes());<br>        outStream.flush();<br>    }<br>构造XML节点的方法有很多，以上方法是直接构造的，需要做这种校验。其他用Schema校验，只要保证输出符合原来的XML Schema定义，没有歧义，没有风险即可。<br>由于对数据进行检验或过滤很难列举全所有的非法数据，建议采用以下两种方式： 1、使用对象的形式来替代直接拼装的XML； 2、对用户输入的数据使用&lt;![CDATA[…]]&gt;封装。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_13" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097242">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:08</span>&nbsp;&nbsp;</div>
			<div class="postText2">推荐做法2：使用存储过程<br>public void doPrivilegedAction(String username, char[] password)<br>            throws SQLException<br>    {<br>        /* … */<br>        try<br>        {<br>            String pwd = hashPassword(password);<br>            // Ensure that the length of user name is legitimate<br>            if ((username.length()) &gt; 8)<br>            {<br>                // Handle error<br>            }<br>            String sqlString = "select * from db_user where username=? and password=?";<br>            CallableStatement cs = connection.prepareCall("{call sp_getUser(?,?)}");<br>            cs.setString(1, username);<br>            cs.setString(2, pwd);<br>            ResultSet rs = cs.executeQuery();<br>            // Authenticate …<br>        }<br>        /* … */<br>    }<br>使用存储过程的效果和使用PreparedStatement类似，其区别是存储过程需要先将SQL语句定义在数据库中。但需要注意的是，存储过程中也可能存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。<br>推荐做法3：对外部输入进行转义<br>public void doPrivilegedAction(String username, char[] password)<br>            throws SQLException<br>    {<br>        /* … */<br>        try<br>        {<br>            String pwd = hashPassword(password);<br>            Codec oe = new OracleEncoder();<br>            String susername = oe.encode(username);<br>            String spwd = oe.encode(pwd);<br>            String sqlString = "SELECT * FROM db_user WHERE username = '"<br>                    + susername + "' AND password = '" + spwd + "'";<br>            Statement stmt = connection.createStatement();<br>            ResultSet rs = stmt.executeQuery(sqlString);<br>            // Authenticate …<br>        }<br>        /* … */ <br>    }<br>对于PreparedStatement无法适用或者存储过程内部也存在动态构造SQL语句的情形，则可以考虑对外部输入做转义。每个DBMS都有一个字符转义机制来告知DBMS输入的是数据而不是代码，如果将所有用户的输入都进行转义，那么DBMS就不会混淆数据和代码，也就不会出现SQL注入了。针对每种数据的转义机制实现，可以使用现有的API工具，比如OWASP ESAPI的escaping routines，也可以使用自己的实现。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_14" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097241">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:07</span>&nbsp;&nbsp;</div>
			<div class="postText2">禁止直接使用外部输入来拼接SQL语句以防止SQL注入<br>说明：如果对于外部输入的数据未经处理，直接用于拼接SQL语句，攻击者可以通过构造特殊形式的输入来改变程序中原本要执行的SQL逻辑，形成SQL注入攻击,导致系统功能异常、信息泄露、数据被非法修改等安全问题。<br>错误示例：<br>public void doPrivilegedAction(String username, char[] password) throws SQLException<br>    {<br>        /* … */<br>        try<br>        {<br>            String pwd = hashPassword(password);<br>            String sqlString = "SELECT * FROM db_user WHERE username = '"<br>                    + username + "' AND password = '" + pwd + "'";<br>            Statement stmt = connection.createStatement();<br>            ResultSet rs = stmt.executeQuery(sqlString);<br>            // Authenticate …<br>        }<br>        /* … */<br>    }<br>上面的代码使用用户输入来拼接SQL语句，但又没有对用户的输入做校验,存在SQL注入风险。当用户为username输入值：jack' OR '1' = '1<br>则SQL语句变成了：SELECT * FROM db_user WHERE username='jack' OR '1'='1' AND<br>password=&lt;PASSWORD&gt;<br>如果jack是有效用户，这样便绕开了对口令的验证。<br>推荐做法1：校验输入长度，并且使用PreparedStatement来防范SQL注入。<br>public void doPrivilegedAction(String username, char[] password)<br>            throws SQLException<br>    {<br>        /* … */<br>        try<br>        {<br>            String pwd = hashPassword(password);<br>            // Ensure that the length of user name is legitimate<br>            if ((username.length()) &gt; 8)<br>            {<br>                // Handle error<br>            }<br>            String sqlString = "select * from db_user where username=? and password=?";<br>            PreparedStatement stmt = connection.prepareStatement(sqlString);<br>            stmt.setString(1, username);<br>            stmt.setString(2, pwd);<br>            ResultSet rs = stmt.executeQuery();<br>            // Authenticate …<br>        }<br>        /* … */<br>    }<br>使用PreparedStatement，输入的参数无法改变原始的SQL语义。上例中，即使攻击者插入类似 jack’ or ‘1’=‘1的字符串，也只会将此字符串当做username来查询。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_15" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097238">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:06</span>&nbsp;&nbsp;</div>
			<div class="postText2">1.	数据校验<br>原则1.1 对外部输入进行校验<br>说明：对于外部输入（包括用户输入、外部接口输入、配置文件、网络数据和环境变量等）可能用于以下场景的情况下，需要检验入参的合法性：<br>1）输入会改变系统状态<br>2）输入作为循环条件<br>3）输入作为数组下标<br>4）输入作为格式化字符串<br>5）输入作为业务数据（如作为命令执行参数、拼装SQL语句、以特定格式持久化）<br>6）输入影响代码逻辑<br>这些情况下如果不对数据作合法性验证，很可能导致DoS、内存越界、格式化字符串漏洞、命令注入、SQL注入、数据破坏等问题。<br>对外部输入验证常见有如下几种方式：<br>（1）校验输入数据长度：<br>如果输入数据是字符串，通过校验输入数据的长度可以加大攻击者实施攻击的难度，防止恶意代码注入等漏洞。<br>（2）校验输入数据的范围：<br>如果输入数据是数值，必须校验数值的范围是否正确，是否合法、在有效值域内，例如在涉及到数组操作、循环条件、计算等安全操作时，若没有进行输入数值有效值域的校验，则可能会造成数组越界、循环异常、计算错误等问题，这可能会被攻击者利用并进行进一步的攻击。<br>（3）输入验证前，对数据进行归一化处理以防止字符转义绕过校验：<br>通过对输入数据进行归一化处理（规范化，按照常用字符进行编码），彻底去除元字符，可以防止字符转义绕过相应的校验而引起的安全漏洞。<br>（4）输入校验应当采用“白名单”形式：<br>“黑名单”和“白名单”是进行数据净化的两种途径。“黑名单”尝试排斥无效的输入，而“白名单”则通过定义一个可接受的字符列表，并移除任何不接受的字符来仅仅接受有效的输入。有效输入值列表通常是一个可预知的、定义良好的集合，并且其大小易于管理。<br>“白名单”的好处在于，程序员可以确定一个字符串中仅仅包含他认为安全的字符。<br>“白名单”比“黑名单”更受推荐的原因是，程序员不必花力气去捕捉所有不可接受的字符，只需确保识别了可接受的字符就可以了。这样一来，程序员就不用绞尽脑汁去考虑攻击者可能尝试哪些字符来绕过检查。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_16" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097237">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:06</span>&nbsp;&nbsp;</div>
			<div class="postText2">0.	规范制定说明<br>0.1前言<br>随着公司业务发展，越来越多的产品被公众、互联网所熟知，并成为安全研究组织的研究对象、黑客的漏洞挖掘目标，容易引起安全问题。安全问题影响的不只是单个产品，甚至有可能影响到公司整体声誉。产品安全涉及需求、设计、实现、部署多个环节，实现的安全是产品安全的重要一环。为了帮助产品开发团队编写安全的代码，减少甚至规避由于编码错误引入安全风险，特制定本规范。<br>《Java语言安全编程规范》参考业界安全编码的研究成果，并结合产品编码实践的经验总结，针对Java语言编程中的输入校验、异常行为、IO操作、序列化、平台安全与运行安全等方面，描述可能导致安全漏洞或潜在风险的常见错误。以期减少SQL注入、敏感信息泄露、格式化字符串攻击、命令注入攻击、目录遍历等典型安全问题。<br>0.2使用对象<br>本规范的读者及使用对象主要为使用Java语言的开发人员、测试人员等。<br>0.3适用范围<br>本规范适合于公司基于Java语言开发的产品。<br>0.4术语定义<br>原则：编程时必须坚持的指导思想。<br>规则：编程时必须遵守的约定。<br>建议：编程时必须加以考虑的约定。<br>说明：对此原则/规则/建议进行必要的解释。<br>错误示例：对此原则/规则/建议从反面给出例子。<br>推荐做法：对此原则/规则/建议从正面给出例子。<br>延伸阅读材料：建议进一步阅读的参考材料。<br>信任边界：系统中处于本身管理和控制下的组件被认为是在信任边界之内，而其他不在系统本身掌控下的连接、数据、以及第三方系统被认为是不受信任的，处于边界之外。<br>非信任代码：非产品包中的代码，如通过网络下载到本地虚拟机中加载并执行的代码。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_17" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097236">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:05</span>&nbsp;&nbsp;</div>
			<div class="postText2">85.	国际化：不要使用 Date.toString() ，Time.toString() 方法。<br>86.	国际化：字符和字符串常量应该放在资源文件中。<br>87.	国际化：不要使用数字的 toString() 方法。<br>88.	国际化：不要使用 StringBuffer , StringTokenizer类。<br>89.	国际化：不要使用 String 类的 compareTo(), equals() 方法。<br>90.	复杂度：建议的最大规模：<br>	继承层次	5层<br>	类的行数	1000行（包含{}）<br>	类的属性	10个<br>	类的方法	20个<br>	类友好方法	10个<br>	类私有方法	15个<br>	类保护方法	10个<br>	类公有方法	10个<br>	类调用方法	20个<br>	方法参数	5个<br>	return语句	1个<br>	方法行数	30行<br>	方法代码	20行<br>	注释比率	30%~50%</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_18" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097228">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:02</span>&nbsp;&nbsp;</div>
			<div class="postText2">54.	尽可能的对接口进行 instanceof 运算。（5级）<br>55.	不要使用 Date[] 而要使用 long[] 替代。<br>56.	不要显式调用 finalize() 。<br>57.	不要使用静态集合，其内存占用增长没有边界。<br>58.	不要重复调用一个方法获取对象，使用局部变量重用对象。<br>59.	线程同步中，使用 notifyAll() 代替 notify()。<br>60.	避免在同步方法中调用另一个同步方法造成的死锁。<br>61.	非同步方法中不能调用 wait() , notify() 方法。<br>62.	使用 wait(), notify() 代替 while(), sleep() 。<br>63.	不要使用同步方法，使用同步块。（5级）<br>64.	把所有的公有方法定义为同步方法。（5级）<br>65.	实现的 Runnable.run() 方法必须是同步方法。 （5级）<br>66.	一个只有abstract方法、final static 属性的类应该定义成接口。<br>67.	在 clone() 方法中应该而且必须使用 super.clone() 而不是 new 。<br>68.	常量必须定义为 final 。<br>69.	在 for 循环中提供终止条件。<br>70.	在 for, while 循环中使用增量计数。<br>71.	使用 StringTokenizer 代替 indexOf() 和 substring() 。<br>72.	不要在构建器中使用非 final 方法。<br>73.	不要对参数进行赋值操作。（5级）<br>74.	不要通过名字比较两个对象的类，应该使用 getClass() 。<br>75.	安全：尽量不要使用内部类。<br>76.	安全：尽量不要使类可以克隆。<br>77.	安全：尽量不要使接口可以序列化。<br>78.	安全：尽量不要使用友好方法、属性和类。<br>79.	Servlet：不要使用 java.beans.Beans.instantiate() 方法。<br>80.	Servlet：不再使用HttpSession时，应该尽早使用 invalidate() 方法释放 。<br>81.	Servlet：不再使用JDBC资源时，应该尽早使用 close() 方法释放 。<br>82.	Servlet：不要使用Servlet的 SingleThreadModel，会消耗大量资源。<br>83.	国际化：不要使用一个字符进行逻辑操作，使用 Characater。<br>84.	国际化：不要进行字符串连接操作，使用MessageFormat 。</div>				
		</div>
	<div class="line"></div>
		<div class="PostList">
			<div class="postTitl2"><a id="PostsList1_rpPosts_TitleUrl_19" href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097227">Re:Linux实用命令整理</a> <span class="postDesc2">hunyihun 2014-12-31 10:02</span>&nbsp;&nbsp;</div>
			<div class="postText2">30.	在接口或者工具类中中定义常量。（5级）<br>31.	使用大写‘L’表示 long 常量。（5级）<br>32.	main() 方法必须是 public static void main(String[])。（5级）<br>33.	对返回类型为 boolean 的方法使用 is 开头，其它类型的不能使用。<br>34.	对非boolean类型取值方法（getter）使用 get 开头，其它类型的不能使用。<br>35.	对于设置值的方法（setter）使用 set 开头，其它类型的不能使用。<br>36.	方法需要有同样数量参数的注释 @param。<br>37.	不要在注释中使用不支持的标记，如：@unsupported 。<br>38.	不要使用 Runtime.exec() 方法。<br>39.	不要自定义本地方法（native method）。<br>40.	使用尽量简洁的的运算符号。<br>41.	使用集合时设置初始容量。<br>42.	单个首字符的比较使用 charAt() 而不用 startsWith() 。<br>43.	对于被除数或者被乘数为2的n次方的乘除运算使用移位运算符 &gt;&gt;, &lt;&lt; 。<br>44.	一个字符的连接使用‘ ’而不使用 “ ”，如：String a = b + 'c'。<br>45.	不要在循环体内调用同步方法和使用 try-catch 块。<br>46.	不要使用不必要的布尔值比较，如：if (a.equals(b)), 而不是 if (a.equals(b)==true)。<br>47.	常量字符串使用 String, 非常量字符串使用 StringBuffer 。<br>48.	在循环条件判断的时候不要使用复杂的表达式。<br>49.	对于“if (condition) do1; else do2;”语句使用条件操作符“if (condition)?do1:do2;”。<br>50.	不要在循环体内定义变量。<br>51.	使用StringBuffer的时候设置初始容量。<br>52.	尽可能的使用局部变量进行运算。<br>53.	尽可能少的使用 ‘!’操作符。（5级）</div>				
		</div>
	<div class="line"></div>
<div class="pager"><div class="Pager">
	共8页:&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">上一页</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=1">1</a>&nbsp;2&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">3</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=4">4</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=5">5</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=6">6</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=7">7</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=8">8</a>&nbsp;<a href="https://www.cnblogs.com/chenyankai/recentcomments.html?page=3">下一页</a>&nbsp;
</div></div>
</div>


			</td>
		</tr>
		</tbody></table>
	</td>
	<td width="10">&nbsp;</td>
	<td valign="top">
		<table align="center" width="100%" height="90" cellspacing="0" cellpadding="5" border="0" bgcolor="white">
		<tbody><tr>
			<td class="banner">
			
			<table width="100%" height="200">
			<tbody><tr>
				<td><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/09/01&#39;);return false;">&lt;</a></td><td align="center">2018年10月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/11/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">30</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td class="CalWeekendDay" align="center">6</td></tr><tr><td class="CalWeekendDay" align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td class="CalWeekendDay" align="center">13</td></tr><tr><td class="CalWeekendDay" align="center">14</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">18</td><td align="center">19</td><td class="CalWeekendDay" align="center">20</td></tr><tr><td class="CalWeekendDay" align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">24</td><td align="center">25</td><td align="center">26</td><td class="CalWeekendDay" align="center">27</td></tr><tr><td class="CalWeekendDay" align="center">28</td><td align="center">29</td><td align="center">30</td><td align="center">31</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td></tr><tr><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td><td class="CalOtherMonthDay" align="center">10</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></td>
			</tr>
			</tbody></table>
				
<h1>&nbsp;公告</h1><br>
<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/chenyankai/">hunyihun</a><br>园龄：<a href="https://home.cnblogs.com/u/chenyankai/" title="入园时间：2013-11-13">4年10个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/chenyankai/followers/">0</a><br>关注：<a href="https://home.cnblogs.com/u/chenyankai/followees/">0</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;bb2fa9a6-374c-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('bb2fa9a6-374c-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
	
				
<h1>&nbsp;导航</h1>
<ul class="list" type="square">
	<li class="listitem"><a id="blog_nav_sitehome" class="listitem" href="https://www.cnblogs.com/">博客园</a></li>
	<li class="listitem"><a id="blog_nav_myhome" class="listitem" href="https://www.cnblogs.com/chenyankai/">首页</a></li>
	<li class="listitem"><a id="blog_nav_newpost" class="listitem" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">发新随笔</a></li>
	<li class="listitem"><a id="MyLinks1_NewArticleLink" class="listitem" href="https://www.cnblogs.com/EnterMyBlog.aspx?NewArticle=1">发新文章</a></li>
	<li class="listitem"><a id="blog_nav_contact" accesskey="9" class="listitem" rel="nofollow" href="https://msg.cnblogs.com/send/hunyihun">联系</a></li>
	<li class="listitem"><a id="blog_nav_rss" class="listitem" href="https://www.cnblogs.com/chenyankai/rss">订阅</a><a id="blog_nav_rss_image" href="https://www.cnblogs.com/chenyankai/rss"><img src="./最新评论 - hunyihun - 博客园2_files/xml.gif" alt="订阅"></a>
	</li><li class="listitem"><a id="blog_nav_admin" class="listitem" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

				<div id="blog_stats">
<h1>&nbsp;统计</h1>
	<ul class="list" type="square">
		<li class="listitem">随笔： 2
		</li><li class="listitem">文章： 0
		</li><li class="listitem">评论： 155
		</li><li class="listitem">引用： 0
	</li>
</ul></div>
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_shortcut" class="sidebar-block">
<h3 class="catListTitle">常用链接</h3>
<ul>
<li><a href="https://www.cnblogs.com/chenyankai/p/" title="我的博客的随笔列表">我的随笔</a></li><li><a href="https://www.cnblogs.com/chenyankai/MyComments.html" title="我发表过的评论列表">我的评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/OtherPosts.html" title="我评论过的随笔列表">我的参与</a></li><li><a href="https://www.cnblogs.com/chenyankai/RecentComments.html" title="我的博客的评论列表">最新评论</a></li><li><a href="https://www.cnblogs.com/chenyankai/tag/" title="我的博客的标签列表">我的标签</a></li>
</ul>
<div id="itemListLin_con" style="display:none;">

</div></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
		<h1 class="listtitle">随笔档案</h1>
		
				<ul class="list" type="square">
			
				<li class="listitem"><a id="CatList_LinkList_0_Link_0" class="listitem" href="https://www.cnblogs.com/chenyankai/archive/2014/09.html">2014年9月 (2)</a> </li>
			
				</ul>
			
	
</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<h3 class="catListTitle">最新评论</h3>
<div class="RecentComment" id="RecentComments">
	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097337">1. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">使用强随机数说明：安全敏感的代码块（如SessionID的生成、挑战算法中的随机数生成等），必须采用强随机数，禁止使用伪随机数。Java API 提供了伪随机数生成器（PRNG）——java.util......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097329">2. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">原则7.3 基于哈希算法的口令安全存储必须加入盐值（salt）说明：单向哈希是在一个方向上工作的哈希函数，从预映射的值很容易计算其哈希值，但要根据特定哈希值产生一个预映射的值却是非常困难的。单向哈希主......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097327">3. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">7.	其它原则7.1 禁止在日志中保存口令、密钥说明： 在日志中不能保存口令和密钥，其中的口令包括明文口令和密文口令。对于敏感信息建议采取以下方法，1）不打印在日志中；2）若因为特殊原因必须要打印日志......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097326">4. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">避免依赖和信任环境变量说明：使用环境变量会带来可以移植性问题，在不同的操作系统中其语义可能有所不同。因此要尽量避免使用环境变量。对于一个值如果有定义的系统属性(System properties)可用......</li>
        <li class="recent_comment_author">--hunyihun</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/chenyankai/p/3951622.html#3097325">5. Re:Linux实用命令整理</a></li>
        <li class="recent_comment_body">所有安全相关的敏感代码都放在一个jar包中，并签名再加密说明：若安全相关的敏感代码（例如进行权限控制或者用户名密码校验的代码）没有放到同一个受信任的jar包中，攻击者可以通过先加载恶意代码（使用相同的......</li>
        <li class="recent_comment_author">--hunyihun</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<h3 class="catListTitle">阅读排行榜</h3>
<div class="RecentComment" id="TopViewPosts"> 
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(67)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(15)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<h3 class="catListTitle">评论排行榜</h3>
<div class="RecentComment" id="TopCommentsPosts">
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/chenyankai/p/3951606.html">1. 源码安装Apache，报错：Cannot use an external APR with the bundled APR-util和httpd: Could not reliably determine the server's fully qualified domain name(97)</a></li><li><a href="https://www.cnblogs.com/chenyankai/p/3951622.html">2. Linux实用命令整理(58)</a></li></ul></div>
</div></div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap" style="display: none;">
<h3 class="catListTitle">推荐排行榜</h3>
<div class="RecentComment">
	<div id="TopDiggPostsBlock"></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			<br>
			
<div class="footer">
	Powered by: <a href="http://www.cnblogs.com/">博客园</a><br>模板提供：<a href="http://blog.hjenglish.com/">沪江博客</a><br>
	Copyright ©2018 hunyihun
</div>
			</td>
		</tr>
		</tbody></table>
	</td>
</tr>
</tbody></table>
<br>



</body></html>