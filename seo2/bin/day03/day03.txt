BIS和BOS:这两个流是高级流
BufferedInputStream:缓存字节输入流
BufferedOutputStream:缓存字节输出流

高级流:会带来一些额外的功能，通常用于简化我们的读写操作

缓存流的功能:内部维护了一个缓存区，用于减少读写次数，提高读写效率

DIS和DOS:这两个也是高级流
DataInputStream:可以方便读取基本类型数据的流
DataOutputStream:可以方便写出基本类型数据的流

字符流:Reader和Writer
Reader:所有字符输入流的父类
Writer:所有字符输出流的父类

字符流处理单位为字符，一次处理一个字符(unicode)
字符流的底层本质上还是使用的读写字节

ISR和OSW
InputStreamReader:字符输入流
OutputStreamWriter:字符输出流

BR和BW：可以按行读写字符串
BufferedReader:缓存字符输入流
BufferedWriter:缓存字符输出流

可以直接读写文本文件的字符流
FileWriter
FileReader

对象的序列化和反序列化的流:
ObjectInputStream:对象的反序列化流
ObjectOutputStream:对象的序列化流
通常我们序列化对象是用于保存对象和传输对象的
所有需要序列化的类，必须都是Serializable的子类(即实现Serializable接口)
序列化的文件是.obj


Java多线程：java语言的一个优势就是处理多线程比较简单

在一个操作系统中会同时运行多个任务（程序），例如LOL、酷狗
1.在操作系统中同时运行的每一个任务都是一个进程
2.对于一个进程（程序）而言，在程序内部也会同时运行多个任务，那么每一个任务 称为一个线程

线程的运行都是并发执行的，所谓的并发：宏观上所有的线程都是同时运行的，但是微观上来看所有的线程都是走走停停

线程的调度：
将CPU的时间划分为若干个时间片断，尽可能的均匀分配给每一个线程，获得CPU的时间片断的线程得以被CPU执行

线程调度                                                       经纪人：宋
CPU                        	    王宝强      
时间片断                                                        档期
线程                                                                剧组

创建线程的两种方式：
Thread类：线程类，其每一个实例表示一个可以并发的线程
使用线程的注意事项：
对于线程调度而言，分配的时间片段长短，具体分配给哪一个线程时间片段，
对于程序而言都是不可控的

线程在执行某段逻辑时可能会发生阻塞现象：sleep阻塞
该阻塞可以指定阻塞时间，并在线程阻塞了该时间后自动返回runnable等待
状态，Thread提供了一个静态方法sleep()，该方法就是用于睡眠阻塞的



线程结束：
1.run方法正常执行完毕
2.run方法执行过程中抛出了一个未捕获的异常（中断异常）

进程的停止：
当一个进程中所有的前台线程停止后，该进程结束

前台线程和后台线程：
后台线程的特点：用法与前台线程无异，只是当一个进程中所有的前台线程都
结束后，无论后台线程是否还在进行中都被强制结束，从而使得进程结束，程序
退出，后台线程也称为守护线程，精灵线程

在运行程序的时候，操作系统会启动一个进程来运行JVM，JVM运行后会创建第一个
前台线程来运行我们的程序main()方法，同时会创建一个后台线程来运行GC（回收
不用的内存对象）

使用Thread类实现多线程和用Runnable接口实现多线程有什么区别？
1.Thread类是Runnable接口的子类，使用Runnable接口实现多线程避免了类单继承的限制
2.使用Runnable接口实现多继承能更清楚的描述数据共享的概念

写出多线程实现的两种方式？



















